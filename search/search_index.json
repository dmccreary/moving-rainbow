{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MicroPython Moving Rainbow Website! About the Moving Rainbow Project Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build entire projects and costumes with 100s of LEDs for under $20. Since 2014 we have been building low-cost kits that teach all the concepts of Computational Thinking ](https://www.coderdojotc.org/CoderDojoTC/computational-thinking/). Note We are no longer accepting pull requests for Arduino C code. Because we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python. Getting Started Our getting started guide has three parts: About Moving Rainbow Code Savvy Kits Build Your Own from Parts Desktop Setup Raspberry Pi Pico The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor. Breadboards In our projects we use 1/2 sized breadboard with 400 tie points. Mode Buttons A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode. Programming the LED strip Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Moving Rainbow Home"},{"location":"#welcome-to-the-micropython-moving-rainbow-website","text":"","title":"Welcome to the MicroPython Moving Rainbow Website!"},{"location":"#about-the-moving-rainbow-project","text":"Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build entire projects and costumes with 100s of LEDs for under $20. Since 2014 we have been building low-cost kits that teach all the concepts of Computational Thinking ](https://www.coderdojotc.org/CoderDojoTC/computational-thinking/). Note We are no longer accepting pull requests for Arduino C code. Because we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python.","title":"About the Moving Rainbow Project"},{"location":"#getting-started","text":"Our getting started guide has three parts: About Moving Rainbow Code Savvy Kits Build Your Own from Parts Desktop Setup","title":"Getting Started"},{"location":"#raspberry-pi-pico","text":"The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor.","title":"Raspberry Pi Pico"},{"location":"#breadboards","text":"In our projects we use 1/2 sized breadboard with 400 tie points.","title":"Breadboards"},{"location":"#mode-buttons","text":"A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode.","title":"Mode Buttons"},{"location":"#programming-the-led-strip","text":"Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Programming the LED strip"},{"location":"challenges/","text":"Moving Rainbow Challenges They are a set of learning challenges for the LED Strip. They are listed in order from the simplest to the most complex. Beginning Challenges These challenges can all be done once you know the following commands: Initialize the NeoPixel Change a Pixel Color Write the Strip For Loop and range Sleep Make a Pixel Blink Draw an RGB Pattern Draw a Rainbow Make a Pixel Fade in and Out Slowly Make a Heartbeat Pattern Make a Pixel Move Down the Strip Change Colors for the Entire LED Strip (wipe) Move a Pixel Down and Back Create a Larson Scanner Pattern Draw Different Levels of Brightness Make Every Other Pixel a Different Color Intermediate Labs These challenges involve more advanced programming such as using: Conditionals Modulo (remainder) Functions Multiple Loops Nested Loops Lists Random Numbers Move the Rainbow Pattern Move a Comet Pattern Create a List of Named Colors Create a Theater Chase Pattern Use The Wheel Function to Draw a Rainbow Do a Color Cycle for the Entire Strip Draw Multiple Color Comets Draw Different Patterns in a Loop Use Random Numbers for Color Selection Random Ripples Draw random ripple patterns on the LED strips where the pixels move out from a single point. Use Random to Simulate Candle Flicker Use Random to For Changing Move Direction Advanced Labs These labs may require some additional components such as: Buttons (momentary press) Potentiometers Speaker/Buzzer Interrupt Service Routines A USB Current Meter A Light Sensor (photoresistor) An OLED display A Wireless Controller Create Separate Python Functions for Five Patterns Create a Mode Variable for Switching the Patterns Use a Button to Change a Pattern Mode Night Light Add a photoresistor that will turn the LED strip on when it is dark in the room. Use Potentiometers to Change Speed Add a potentiometer and change the speed of a display pattern Use Potentiometers to Change Brightness Add a potentiometer and change the brightness of a display pattern Create a Demo Auto-Cycle Pattern a Button to Advance the Mode Calculate the Power Draw of Different Colors Get a USB power meter from the instructor. Measure the current draw for each of the different colors. Calculate the time for a 2,500-milliamp-hour battery pack for various patterns. Connect an OLED display that shows the pattern, color and brightness of the LED strip. Add Buttons to Change the Parameters with the OLED Add a Sound Add a speaker or buzzer to play a sound when a button is pressed. Simon Game Display a pattern on four pixels of the LED strip and have the user repeat the pattern using four buttons. Play different tones for each pixel. Zone Game Draw a zone of a different color in the center of the strip. Move a pixel down and strip and give a player a point if they press the button in the strip. Use sound and pixel colors to show the points score. Make the zone smaller and the speed faster as the game progresses. Random Zone Add randomization to your Zone game to make the zone move in random directions. Clock Turn your LED strip into a clock. You can display each digit using a binary structure. Wireless Labs Web Page Color Control Create a web page that changes the color of the LED strip. Create a Web Page to Change the Pattern Create a web page that changes the pattern Pattern, Brightness and Speed Create a web page that changes the pattern, brightness and speed of a pattern. Display the Weather Forecast Use a web service to get the weather forecast for the current day. Change the color of the display: Yellow for Sunny Gray for Cloudy Red for Rain White for Snow You can use this example to get started.","title":"Challenges"},{"location":"challenges/#moving-rainbow-challenges","text":"They are a set of learning challenges for the LED Strip. They are listed in order from the simplest to the most complex.","title":"Moving Rainbow Challenges"},{"location":"challenges/#beginning-challenges","text":"These challenges can all be done once you know the following commands: Initialize the NeoPixel Change a Pixel Color Write the Strip For Loop and range Sleep","title":"Beginning Challenges"},{"location":"challenges/#make-a-pixel-blink","text":"","title":"Make a Pixel Blink"},{"location":"challenges/#draw-an-rgb-pattern","text":"","title":"Draw an RGB Pattern"},{"location":"challenges/#draw-a-rainbow","text":"","title":"Draw a Rainbow"},{"location":"challenges/#make-a-pixel-fade-in-and-out-slowly","text":"","title":"Make a Pixel Fade in and Out Slowly"},{"location":"challenges/#make-a-heartbeat-pattern","text":"","title":"Make a Heartbeat Pattern"},{"location":"challenges/#make-a-pixel-move-down-the-strip","text":"","title":"Make a Pixel Move Down the Strip"},{"location":"challenges/#change-colors-for-the-entire-led-strip-wipe","text":"","title":"Change Colors for the Entire LED Strip (wipe)"},{"location":"challenges/#move-a-pixel-down-and-back","text":"","title":"Move a Pixel Down and Back"},{"location":"challenges/#create-a-larson-scanner-pattern","text":"","title":"Create a Larson Scanner Pattern"},{"location":"challenges/#draw-different-levels-of-brightness","text":"","title":"Draw Different Levels of Brightness"},{"location":"challenges/#make-every-other-pixel-a-different-color","text":"","title":"Make Every Other Pixel a Different Color"},{"location":"challenges/#intermediate-labs","text":"These challenges involve more advanced programming such as using: Conditionals Modulo (remainder) Functions Multiple Loops Nested Loops Lists Random Numbers","title":"Intermediate Labs"},{"location":"challenges/#move-the-rainbow-pattern","text":"","title":"Move the Rainbow Pattern"},{"location":"challenges/#move-a-comet-pattern","text":"","title":"Move a Comet Pattern"},{"location":"challenges/#create-a-list-of-named-colors","text":"","title":"Create a List of Named Colors"},{"location":"challenges/#create-a-theater-chase-pattern","text":"","title":"Create a Theater Chase Pattern"},{"location":"challenges/#use-the-wheel-function-to-draw-a-rainbow","text":"","title":"Use The Wheel Function to Draw a Rainbow"},{"location":"challenges/#do-a-color-cycle-for-the-entire-strip","text":"","title":"Do a Color Cycle for the Entire Strip"},{"location":"challenges/#draw-multiple-color-comets","text":"","title":"Draw Multiple Color Comets"},{"location":"challenges/#draw-different-patterns-in-a-loop","text":"","title":"Draw Different Patterns in a Loop"},{"location":"challenges/#use-random-numbers-for-color-selection","text":"","title":"Use Random Numbers for Color Selection"},{"location":"challenges/#random-ripples","text":"Draw random ripple patterns on the LED strips where the pixels move out from a single point.","title":"Random Ripples"},{"location":"challenges/#use-random-to-simulate-candle-flicker","text":"","title":"Use Random to Simulate Candle Flicker"},{"location":"challenges/#use-random-to-for-changing-move-direction","text":"","title":"Use Random to For Changing Move Direction"},{"location":"challenges/#advanced-labs","text":"These labs may require some additional components such as: Buttons (momentary press) Potentiometers Speaker/Buzzer Interrupt Service Routines A USB Current Meter A Light Sensor (photoresistor) An OLED display A Wireless Controller","title":"Advanced Labs"},{"location":"challenges/#create-separate-python-functions-for-five-patterns","text":"","title":"Create Separate Python Functions for Five Patterns"},{"location":"challenges/#create-a-mode-variable-for-switching-the-patterns","text":"","title":"Create a Mode Variable for Switching the Patterns"},{"location":"challenges/#use-a-button-to-change-a-pattern-mode","text":"","title":"Use a Button to Change a Pattern Mode"},{"location":"challenges/#night-light","text":"Add a photoresistor that will turn the LED strip on when it is dark in the room.","title":"Night Light"},{"location":"challenges/#use-potentiometers-to-change-speed","text":"Add a potentiometer and change the speed of a display pattern","title":"Use Potentiometers to Change Speed"},{"location":"challenges/#use-potentiometers-to-change-brightness","text":"Add a potentiometer and change the brightness of a display pattern","title":"Use Potentiometers to Change Brightness"},{"location":"challenges/#create-a-demo-auto-cycle-pattern-a-button-to-advance-the-mode","text":"","title":"Create a Demo Auto-Cycle Pattern a Button to Advance the Mode"},{"location":"challenges/#calculate-the-power-draw-of-different-colors","text":"Get a USB power meter from the instructor. Measure the current draw for each of the different colors. Calculate the time for a 2,500-milliamp-hour battery pack for various patterns.","title":"Calculate the Power Draw of Different Colors"},{"location":"challenges/#connect-an-oled-display-that-shows-the-pattern-color-and-brightness-of-the-led-strip","text":"","title":"Connect an OLED display that shows the pattern, color and brightness of the LED strip."},{"location":"challenges/#add-buttons-to-change-the-parameters-with-the-oled","text":"","title":"Add Buttons to Change the Parameters with the OLED"},{"location":"challenges/#add-a-sound","text":"Add a speaker or buzzer to play a sound when a button is pressed.","title":"Add a Sound"},{"location":"challenges/#simon-game","text":"Display a pattern on four pixels of the LED strip and have the user repeat the pattern using four buttons. Play different tones for each pixel.","title":"Simon Game"},{"location":"challenges/#zone-game","text":"Draw a zone of a different color in the center of the strip. Move a pixel down and strip and give a player a point if they press the button in the strip. Use sound and pixel colors to show the points score. Make the zone smaller and the speed faster as the game progresses.","title":"Zone Game"},{"location":"challenges/#random-zone","text":"Add randomization to your Zone game to make the zone move in random directions.","title":"Random Zone"},{"location":"challenges/#clock","text":"Turn your LED strip into a clock. You can display each digit using a binary structure.","title":"Clock"},{"location":"challenges/#wireless-labs","text":"","title":"Wireless Labs"},{"location":"challenges/#web-page-color-control","text":"Create a web page that changes the color of the LED strip.","title":"Web Page Color Control"},{"location":"challenges/#create-a-web-page-to-change-the-pattern","text":"Create a web page that changes the pattern","title":"Create a Web Page to Change the Pattern"},{"location":"challenges/#pattern-brightness-and-speed","text":"Create a web page that changes the pattern, brightness and speed of a pattern.","title":"Pattern, Brightness and Speed"},{"location":"challenges/#display-the-weather-forecast","text":"Use a web service to get the weather forecast for the current day. Change the color of the display: Yellow for Sunny Gray for Cloudy Red for Rain White for Snow You can use this example to get started.","title":"Display the Weather Forecast"},{"location":"resources/","text":"Moving Rainbow Resources References CodeSavvy CoderDojo International CoderDojo Twin Cities (now part of the Code Savvy Explorer Program)","title":"Resources"},{"location":"resources/#moving-rainbow-resources","text":"","title":"Moving Rainbow Resources"},{"location":"resources/#references","text":"CodeSavvy CoderDojo International CoderDojo Twin Cities (now part of the Code Savvy Explorer Program)","title":"References"},{"location":"getting-started/about/","text":"About Moving Rainbow What is the lowest-cost and most fun kit that teaches computational thinking? This is the question that has been the driving force behind the Moving Rainbow project. We think the answer is the $10 Moving Rainbow kit. Let us tell you why. Background of the Moving Rainbow In 2014 the IoT Hackday program in Minnesota was looking for a way to introduce new students to the Internet of Things and to teach computer programming with microcontrollers. Dan McCreary developed a series of projects and tried them on in classrooms. He quickly learned that kids loved working with LEDs and making colorful patterns with rows of LEDs. However, these projects required lots of individual components (LEDs, resistors, Arduino etc.). Eventually, Dan discovered a new type of LEDs that came in long strips and each pixel contained an individually addressable red, green and blue pixel. These projects were easy to hook up and the students could focus on programming the patterns on the LED strips. Dan's first \"kits\" contained an Arduino Nano and only 12 pixels. But he could provide the kits to teachers, mentors, and students for under $25. Since then the cost of both the microcontrollers and the LED strips have come down. And since 2021 the curriculum has shifted from C on Arduino to Python on Picos and similar powerful but low-cost microcontrollers. Today, the Moving Rainbow systems include kits, instructions for building your own kits and extensive lesson plans on both the Pico and the Pico \"W\" (wireless). Color, Motion, Fun and Design So why pick this specific design? At the center of this design is hundreds of hours of careful observation of students actually using these devices. With each iteration, we continue to build, test, observe and change our design to meet the needs of our students. Here is what we have learned: Kids love color Kids love motion Kids love to have their OWN devices to show their friends and family. If they can take them home and show them off they take ownership of the skills they need to continually create and expand the features of these little devices. These principles are simple, but they are well-tested and we think they will persist even as technology progresses. We expect to have more powerful devices and bigger and better displays. But the stepping stones will remain. Licenses All Moving Rainbow curricula are licensed under Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) . This means you can use and modify the materials in your classroom as long as you don't resell the content for profit. Contact If you have further questions about the Moving Rainbow Project by contacting Dan on his LinkedIn page. We are continually looking for schools, teachers, mentors and students that would like to promote computational thinking in our classrooms and at home.","title":"About"},{"location":"getting-started/about/#about-moving-rainbow","text":"What is the lowest-cost and most fun kit that teaches computational thinking? This is the question that has been the driving force behind the Moving Rainbow project. We think the answer is the $10 Moving Rainbow kit. Let us tell you why.","title":"About Moving Rainbow"},{"location":"getting-started/about/#background-of-the-moving-rainbow","text":"In 2014 the IoT Hackday program in Minnesota was looking for a way to introduce new students to the Internet of Things and to teach computer programming with microcontrollers. Dan McCreary developed a series of projects and tried them on in classrooms. He quickly learned that kids loved working with LEDs and making colorful patterns with rows of LEDs. However, these projects required lots of individual components (LEDs, resistors, Arduino etc.). Eventually, Dan discovered a new type of LEDs that came in long strips and each pixel contained an individually addressable red, green and blue pixel. These projects were easy to hook up and the students could focus on programming the patterns on the LED strips. Dan's first \"kits\" contained an Arduino Nano and only 12 pixels. But he could provide the kits to teachers, mentors, and students for under $25. Since then the cost of both the microcontrollers and the LED strips have come down. And since 2021 the curriculum has shifted from C on Arduino to Python on Picos and similar powerful but low-cost microcontrollers. Today, the Moving Rainbow systems include kits, instructions for building your own kits and extensive lesson plans on both the Pico and the Pico \"W\" (wireless).","title":"Background of the Moving Rainbow"},{"location":"getting-started/about/#color-motion-fun-and-design","text":"So why pick this specific design? At the center of this design is hundreds of hours of careful observation of students actually using these devices. With each iteration, we continue to build, test, observe and change our design to meet the needs of our students. Here is what we have learned: Kids love color Kids love motion Kids love to have their OWN devices to show their friends and family. If they can take them home and show them off they take ownership of the skills they need to continually create and expand the features of these little devices. These principles are simple, but they are well-tested and we think they will persist even as technology progresses. We expect to have more powerful devices and bigger and better displays. But the stepping stones will remain.","title":"Color, Motion, Fun and Design"},{"location":"getting-started/about/#licenses","text":"All Moving Rainbow curricula are licensed under Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) . This means you can use and modify the materials in your classroom as long as you don't resell the content for profit.","title":"Licenses"},{"location":"getting-started/about/#contact","text":"If you have further questions about the Moving Rainbow Project by contacting Dan on his LinkedIn page. We are continually looking for schools, teachers, mentors and students that would like to promote computational thinking in our classrooms and at home.","title":"Contact"},{"location":"getting-started/connections/","text":"Circuit Connections Because this guide is focused on teaching computational thinking, we don't spend much time on circuits and wiring diagrams. We try to keep the circuits and wiring diagrams as simple as possible. For the basic NeoPixel strip are only three wires you need to conn","title":"Circuit Connections"},{"location":"getting-started/connections/#circuit-connections","text":"Because this guide is focused on teaching computational thinking, we don't spend much time on circuits and wiring diagrams. We try to keep the circuits and wiring diagrams as simple as possible. For the basic NeoPixel strip are only three wires you need to conn","title":"Circuit Connections"},{"location":"getting-started/desktop-setup/","text":"Desktop Setup In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons. About Thonny Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi. Step 1: Install Thonny The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software. Thonny Versions These labs have all been tested on Thonny Version 4.0.4 . Step 2: Configure the MicroPython Firmware After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware. Manually Downloading the Firmware There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware Step 3: Configure Interpreter Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected. Thonny Firmware List After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#desktop-setup","text":"In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#about-thonny","text":"Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.","title":"About Thonny"},{"location":"getting-started/desktop-setup/#step-1-install-thonny","text":"The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software.","title":"Step 1: Install Thonny"},{"location":"getting-started/desktop-setup/#thonny-versions","text":"These labs have all been tested on Thonny Version 4.0.4 .","title":"Thonny Versions"},{"location":"getting-started/desktop-setup/#step-2-configure-the-micropython-firmware","text":"After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.","title":"Step 2: Configure the MicroPython Firmware"},{"location":"getting-started/desktop-setup/#manually-downloading-the-firmware","text":"There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware","title":"Manually Downloading the Firmware"},{"location":"getting-started/desktop-setup/#step-3-configure-interpreter","text":"Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected.","title":"Step 3: Configure Interpreter"},{"location":"getting-started/desktop-setup/#thonny-firmware-list","text":"After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Thonny Firmware List"},{"location":"getting-started/kits/","text":"Moving Rainbow Kits These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10 Standard Parts Our standard kit contains the following parts: A Raspberry Pi Pico ($4) or \"W\" ($6) with header pins soldered in place A 1/2-size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires Optional Parts USB Connectors Most of our classrooms will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector. Batteries and Battery Packs If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern) LED Strip and Rings There are hundreds of variations of WS2812B LED strips and fairy lights. We usually purchase them in 1-meter strips with 60 pixels per meter. Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes. EBay Search for SW2812B If you are creating costumes that might get wet in the rain, we suggest getting the versions that are encased in a waterproof silicon tube or in a waterproof silicon coating. LED Fairy Lights","title":"Standard Kits"},{"location":"getting-started/kits/#moving-rainbow-kits","text":"These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10","title":"Moving Rainbow Kits"},{"location":"getting-started/kits/#standard-parts","text":"Our standard kit contains the following parts: A Raspberry Pi Pico ($4) or \"W\" ($6) with header pins soldered in place A 1/2-size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires","title":"Standard Parts"},{"location":"getting-started/kits/#optional-parts","text":"","title":"Optional Parts"},{"location":"getting-started/kits/#usb-connectors","text":"Most of our classrooms will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector.","title":"USB Connectors"},{"location":"getting-started/kits/#batteries-and-battery-packs","text":"If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern)","title":"Batteries and Battery Packs"},{"location":"getting-started/kits/#led-strip-and-rings","text":"There are hundreds of variations of WS2812B LED strips and fairy lights. We usually purchase them in 1-meter strips with 60 pixels per meter. Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes. EBay Search for SW2812B If you are creating costumes that might get wet in the rain, we suggest getting the versions that are encased in a waterproof silicon tube or in a waterproof silicon coating.","title":"LED Strip and Rings"},{"location":"getting-started/kits/#led-fairy-lights","text":"","title":"LED Fairy Lights"},{"location":"getting-started/parts/","text":"Purchasing Your Own Parts In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guide is for mentors, parents and students that would like to build their own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on online sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these sites change frequently. Soldering Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school. Headers Many of the Pico's don't come with headers. You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay. Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors MicroControllers Raspberry Pi Pico We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins. NeoPixels NeoPixels are parts that contain three LEDs and logic to process an incoming data stream. Each NeoPixel will look at the incoming data and extract the 8-bit values for its own red, green and blue LED brightness. It then sends the data signal on to the next NeoPixel. Header Pins If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip Breadboards We use 400-tie 1/2 size breadboards. You can purchase them on E-Bay for around $1.50 each in quantity 10. Momentary Push Buttons Tactile Switchs We use these buttons Part Description: 100PCS B3F-4055 12 12 7.3 Tactile Switch 12x12x7.3mm The caps are 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch on eBay Boxes Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits. MicroPython Site For more parts, see the CoderDojoTC MicroPython website .","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#purchasing-your-own-parts","text":"In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guide is for mentors, parents and students that would like to build their own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on online sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these sites change frequently.","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#soldering","text":"Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school.","title":"Soldering"},{"location":"getting-started/parts/#headers","text":"Many of the Pico's don't come with headers. You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay. Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors","title":"Headers"},{"location":"getting-started/parts/#microcontrollers","text":"","title":"MicroControllers"},{"location":"getting-started/parts/#raspberry-pi-pico","text":"We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins.","title":"Raspberry Pi Pico"},{"location":"getting-started/parts/#neopixels","text":"NeoPixels are parts that contain three LEDs and logic to process an incoming data stream. Each NeoPixel will look at the incoming data and extract the 8-bit values for its own red, green and blue LED brightness. It then sends the data signal on to the next NeoPixel.","title":"NeoPixels"},{"location":"getting-started/parts/#header-pins","text":"If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip","title":"Header Pins"},{"location":"getting-started/parts/#breadboards","text":"We use 400-tie 1/2 size breadboards. You can purchase them on E-Bay for around $1.50 each in quantity 10.","title":"Breadboards"},{"location":"getting-started/parts/#momentary-push-buttons","text":"Tactile Switchs We use these buttons Part Description: 100PCS B3F-4055 12 12 7.3 Tactile Switch 12x12x7.3mm The caps are 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch on eBay","title":"Momentary Push Buttons"},{"location":"getting-started/parts/#boxes","text":"Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits.","title":"Boxes"},{"location":"getting-started/parts/#micropython-site","text":"For more parts, see the CoderDojoTC MicroPython website .","title":"MicroPython Site"},{"location":"lessons/","text":"Moving Rainbow Lessons Simple Individual Patterns Blink - blink the first pixel red on and off Fade In and Out - Make the first pixel fade in and out Heartbeat - Change the first red pixel to beat like a heartbeat Red, Green and Blue - Draw red, green and blue colors in different places Color Wheel - draw all the colors of the rainbow A Better Dimmer - making our dimmer more uniform Moving Pixel - move a pixel up and down the LED strip Color Wipe - change the color one pixel at a time Bounce - dots crash in the center of the strip Comet - make a block of color move with a dimming tail Moving Rainbow - move a block of colors Rainbow Cycle - cycle every pixel through all the colors of the rainbow Larson Scanner - famous Cylon eye and KITT car scanning pattern Random Colors - draw random colors at each pixel Twinkle - random pixels twinkle on for a brief second Ripple - simulated drops in a pond in 1-D Random Bounce - random points bounce around Candle - simulated candle flickers with randomness Theater Chase - classic running light patterns popular in signs Moving Bands - moving bands of color Rotating Patterns Modes - assign a mode to each pattern Button Modes - use buttons to change a mode","title":"List of Lessons"},{"location":"lessons/#moving-rainbow-lessons","text":"","title":"Moving Rainbow Lessons"},{"location":"lessons/#simple-individual-patterns","text":"Blink - blink the first pixel red on and off Fade In and Out - Make the first pixel fade in and out Heartbeat - Change the first red pixel to beat like a heartbeat Red, Green and Blue - Draw red, green and blue colors in different places Color Wheel - draw all the colors of the rainbow A Better Dimmer - making our dimmer more uniform Moving Pixel - move a pixel up and down the LED strip Color Wipe - change the color one pixel at a time Bounce - dots crash in the center of the strip Comet - make a block of color move with a dimming tail Moving Rainbow - move a block of colors Rainbow Cycle - cycle every pixel through all the colors of the rainbow Larson Scanner - famous Cylon eye and KITT car scanning pattern Random Colors - draw random colors at each pixel Twinkle - random pixels twinkle on for a brief second Ripple - simulated drops in a pond in 1-D Random Bounce - random points bounce around Candle - simulated candle flickers with randomness Theater Chase - classic running light patterns popular in signs Moving Bands - moving bands of color","title":"Simple Individual Patterns"},{"location":"lessons/#rotating-patterns","text":"Modes - assign a mode to each pattern Button Modes - use buttons to change a mode","title":"Rotating Patterns"},{"location":"lessons/01-blink/","text":"Blink Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 ) Exercises Change the Color Lab Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens? Change the Position Lab Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens? Change the Sleep Time What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005 RGB Lab Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened? Why Do We Need Strip.Write? Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line? LED Strip State What happens if you stop the program when the LED strip LEDs are on? On Your Own What if you extended the lab to more positions and colors?","title":"Blink"},{"location":"lessons/01-blink/#blink","text":"Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 )","title":"Blink"},{"location":"lessons/01-blink/#exercises","text":"","title":"Exercises"},{"location":"lessons/01-blink/#change-the-color-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens?","title":"Change the Color Lab"},{"location":"lessons/01-blink/#change-the-position-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens?","title":"Change the Position Lab"},{"location":"lessons/01-blink/#change-the-sleep-time","text":"What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005","title":"Change the Sleep Time"},{"location":"lessons/01-blink/#rgb-lab","text":"Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened?","title":"RGB Lab"},{"location":"lessons/01-blink/#why-do-we-need-stripwrite","text":"Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line?","title":"Why Do We Need Strip.Write?"},{"location":"lessons/01-blink/#led-strip-state","text":"What happens if you stop the program when the LED strip LEDs are on?","title":"LED Strip State"},{"location":"lessons/01-blink/#on-your-own","text":"What if you extended the lab to more positions and colors?","title":"On Your Own"},{"location":"lessons/02-fade-in-and-out/","text":"Fade In and Out Lab What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out"},{"location":"lessons/02-fade-in-and-out/#fade-in-and-out-lab","text":"What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out Lab"},{"location":"lessons/03-heartbeat/","text":"Heartbeat Lab What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat"},{"location":"lessons/03-heartbeat/#heartbeat-lab","text":"What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat Lab"},{"location":"lessons/04-red-green-blue/","text":"","title":"Red, Green and Blue"},{"location":"lessons/05-color-wheel/","text":"Color Wheel Lab What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red Full Program This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Color Wheel"},{"location":"lessons/05-color-wheel/#color-wheel-lab","text":"What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red","title":"Color Wheel Lab"},{"location":"lessons/05-color-wheel/#full-program","text":"This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Full Program"},{"location":"lessons/06-linear-dimmer/","text":"Linear Dimmer We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html Gamma Correction Table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"A Better Dimmer"},{"location":"lessons/06-linear-dimmer/#linear-dimmer","text":"We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html","title":"Linear Dimmer"},{"location":"lessons/06-linear-dimmer/#gamma-correction-table","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"Gamma Correction Table"},{"location":"lessons/07-motion/","text":"Motion Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period. Move a Red Pixel The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move. Experiments Change the Delay Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay. Down and Back Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) Advanced Lab: Timeing the Write You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay. Have Some Fun! Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Moving Pixel"},{"location":"lessons/07-motion/#motion","text":"Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period.","title":"Motion"},{"location":"lessons/07-motion/#move-a-red-pixel","text":"The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move.","title":"Move a Red Pixel"},{"location":"lessons/07-motion/#experiments","text":"","title":"Experiments"},{"location":"lessons/07-motion/#change-the-delay","text":"Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay.","title":"Change the Delay"},{"location":"lessons/07-motion/#down-and-back","text":"Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 )","title":"Down and Back"},{"location":"lessons/07-motion/#advanced-lab-timeing-the-write","text":"You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay.","title":"Advanced Lab: Timeing the Write"},{"location":"lessons/07-motion/#have-some-fun","text":"Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Have Some Fun!"},{"location":"lessons/08-color-wipe/","text":"Color Wipe This lesson shows you how to change the color of the entire LED strip pixel by pixel. There will be two delays that we can control: the delay between each pixel update - this is usually about 1/20th of a second the delay between colors - this is usually about 1 to 2 seconds A Simple Color Wipe Function To write this program, we will create a simple Python function that will cycle through all the colors in a list. Our color list will look like this: 1 2 3 4 5 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) ... etc ... colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) Now with this list 1 2 3 4 5 6 7 8 9 def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () # the delay between each pixel draw sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from time import sleep # most people have a heart rate of around 60-70 beats per minute # If you add a once second deplay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 60 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) while True : color_wipe ( . 05 , 1 )","title":"Color Wipe"},{"location":"lessons/08-color-wipe/#color-wipe","text":"This lesson shows you how to change the color of the entire LED strip pixel by pixel. There will be two delays that we can control: the delay between each pixel update - this is usually about 1/20th of a second the delay between colors - this is usually about 1 to 2 seconds","title":"Color Wipe"},{"location":"lessons/08-color-wipe/#a-simple-color-wipe-function","text":"To write this program, we will create a simple Python function that will cycle through all the colors in a list. Our color list will look like this: 1 2 3 4 5 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) ... etc ... colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) Now with this list 1 2 3 4 5 6 7 8 9 def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () # the delay between each pixel draw sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from time import sleep # most people have a heart rate of around 60-70 beats per minute # If you add a once second deplay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 60 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) while True : color_wipe ( . 05 , 1 )","title":"A Simple Color Wipe Function"},{"location":"lessons/08-moving-bands/","text":"Moving Bands of Color In this lesson, we will create a program that will move a set of bands of color down the LED strip. To do this we will create a function called draw_band(start, end, color) that will fill a range of pixels with a given color. 1 2 3 4 def draw_band ( start , end , color , delay ): # draw the band from start to end for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color This works, but we also have the problem that the last pixel does not get erased 1 2 3 4 5 6 7 8 9 def draw_band ( start , end , color , erase_tail , delay ): # draw the band from start to end for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color # erase the last pixel on the erase tail band if erase_tail and start > 0 : strip [( start - 1 ) % NUMBER_PIXELS ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) We can then draw three \"bands\" of color like this: 1 2 3 draw_band ( 0 , 9 , 'red' ) draw_band ( 10 , 19 , 'green' ) draw_band ( 20 , 29 , 'blue' ) We can make this group of bands appear to move by adding a offset to the start like this: 1 2 3 4 for i in range ( 0 , NUMBER_PIXELS ) draw_band ( i , i + 9 , 'red' ) draw_band ( i + 10 , i + 19 , 'green' ) draw_band ( i + 20 , i + 29 , 'blue' ) This will work fine until the value of i plus the offset exceeds the length of the LED strip. To get around this, we should never write to location i by itself. We should always divide i by the strip lenght and write to the remainder, what is call the modulo. We just have to change one line in the draw_band function: 1 2 3 4 def draw_band ( start , end , color ): for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color strip . write ()","title":"Moving Bands"},{"location":"lessons/08-moving-bands/#moving-bands-of-color","text":"In this lesson, we will create a program that will move a set of bands of color down the LED strip. To do this we will create a function called draw_band(start, end, color) that will fill a range of pixels with a given color. 1 2 3 4 def draw_band ( start , end , color , delay ): # draw the band from start to end for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color This works, but we also have the problem that the last pixel does not get erased 1 2 3 4 5 6 7 8 9 def draw_band ( start , end , color , erase_tail , delay ): # draw the band from start to end for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color # erase the last pixel on the erase tail band if erase_tail and start > 0 : strip [( start - 1 ) % NUMBER_PIXELS ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) We can then draw three \"bands\" of color like this: 1 2 3 draw_band ( 0 , 9 , 'red' ) draw_band ( 10 , 19 , 'green' ) draw_band ( 20 , 29 , 'blue' ) We can make this group of bands appear to move by adding a offset to the start like this: 1 2 3 4 for i in range ( 0 , NUMBER_PIXELS ) draw_band ( i , i + 9 , 'red' ) draw_band ( i + 10 , i + 19 , 'green' ) draw_band ( i + 20 , i + 29 , 'blue' ) This will work fine until the value of i plus the offset exceeds the length of the LED strip. To get around this, we should never write to location i by itself. We should always divide i by the strip lenght and write to the remainder, what is call the modulo. We just have to change one line in the draw_band function: 1 2 3 4 def draw_band ( start , end , color ): for i in range ( start , end ): strip [ i % NUMBER_PIXELS ] = color strip . write ()","title":"Moving Bands of Color"},{"location":"lessons/09-comet-tail/","text":"Comet Tail In this lesson we will make a pattern of light like a comet tail. The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet. The Draw Comet Tail Function Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet. In general, each pixel will be half as bright and the prior pixel. The \"levels\" of brightness can be stored in a list or calculated. Our list will look like this: 1 2 # brightness levels starting with max and going to 1 levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] Our function will have three parameters: The offset from pixel 0 The color to draw the pixel as a tuple of three integers The delay between the draws which will control the speed that the comet appears to move down the strip Here is an example of this function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): % make sure we are within the range of the LED strip offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) # set the target and scale and round to the interger value strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) The most complex line is this one: 1 strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) This line sets the RGB values of the target. It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet. After it does the multiplication, it must use the int() function to round the value to the nearest integer. Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , white ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for color_index in range ( 0 , color_count ): for i in range ( 0 , NUMBER_PIXELS ): draw_comet_tail ( counter , colors [ color_index ], . 005 ) counter += 1 print ( counter )","title":"Comet Tail"},{"location":"lessons/09-comet-tail/#comet-tail","text":"In this lesson we will make a pattern of light like a comet tail. The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet.","title":"Comet Tail"},{"location":"lessons/09-comet-tail/#the-draw-comet-tail-function","text":"Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet. In general, each pixel will be half as bright and the prior pixel. The \"levels\" of brightness can be stored in a list or calculated. Our list will look like this: 1 2 # brightness levels starting with max and going to 1 levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] Our function will have three parameters: The offset from pixel 0 The color to draw the pixel as a tuple of three integers The delay between the draws which will control the speed that the comet appears to move down the strip Here is an example of this function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): % make sure we are within the range of the LED strip offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) # set the target and scale and round to the interger value strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) The most complex line is this one: 1 strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) This line sets the RGB values of the target. It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet. After it does the multiplication, it must use the int() function to round the value to the nearest integer.","title":"The Draw Comet Tail Function"},{"location":"lessons/09-comet-tail/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , white ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for color_index in range ( 0 , color_count ): for i in range ( 0 , NUMBER_PIXELS ): draw_comet_tail ( counter , colors [ color_index ], . 005 ) counter += 1 print ( counter )","title":"Full Program"},{"location":"lessons/10-moving-rainbow/","text":"Moving Rainbow In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab. The Classic Rainbow Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors. Repeating the Moving Rainbow Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop. Improving on the Moving Rainbow This program is simple to read, but there are several ways we could improve it. One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip. This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd. For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip. We can achieve this by using the modulo function. It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#moving-rainbow","text":"In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab.","title":"Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#the-classic-rainbow","text":"Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors.","title":"The Classic Rainbow"},{"location":"lessons/10-moving-rainbow/#repeating-the-moving-rainbow","text":"Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop.","title":"Repeating the Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#improving-on-the-moving-rainbow","text":"This program is simple to read, but there are several ways we could improve it. One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip. This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd. For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip. We can achieve this by using the modulo function. It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Improving on the Moving Rainbow"},{"location":"lessons/11-rainbow-cycle/","text":"Rainbow Cycle In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow. The Rainbow Cycle Function We create a function called rainbow_cycle() that has three parameters. The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over. 1 2 3 4 5 6 7 8 9 10 def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) Next, we place a while True() loop at end and call the function repeatedly. Power Considerations This program has the ability to drive every single pixel on the strip. This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply. To get around this you can up the skip parameter to only turn on every 2nd, 3rd or 4th pixel. The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts. Full Program Here is the full program you can run. Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) # s[eed is an integer from 1 to 30 speed = 2 # skip = 1 is every pixel, 2 is every other pixel etc. # the hither skip the lower the overall power skip = 3 while True : rainbow_cycle ( . 01 , speed , skip )","title":"Rainbow Cycle"},{"location":"lessons/11-rainbow-cycle/#rainbow-cycle","text":"In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow.","title":"Rainbow Cycle"},{"location":"lessons/11-rainbow-cycle/#the-rainbow-cycle-function","text":"We create a function called rainbow_cycle() that has three parameters. The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over. 1 2 3 4 5 6 7 8 9 10 def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) Next, we place a while True() loop at end and call the function repeatedly.","title":"The Rainbow Cycle Function"},{"location":"lessons/11-rainbow-cycle/#power-considerations","text":"This program has the ability to drive every single pixel on the strip. This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply. To get around this you can up the skip parameter to only turn on every 2nd, 3rd or 4th pixel. The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts.","title":"Power Considerations"},{"location":"lessons/11-rainbow-cycle/#full-program","text":"Here is the full program you can run. Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) # s[eed is an integer from 1 to 30 speed = 2 # skip = 1 is every pixel, 2 is every other pixel etc. # the hither skip the lower the overall power skip = 3 while True : rainbow_cycle ( . 01 , speed , skip )","title":"Full Program"},{"location":"lessons/15-random/","text":"Random Drawing In this lesson we will introduce the ability to draw random colors at random pixels. This allows us to create more natural patterns such as the flicking light of a candle. The Random Functions We need a function that will generate a random integer between a range of values. This is called the randint() function and it takes either one or two parameters. In our case, we can just pass in the minimum and maximum values: 1 randint ( 0 , 256 ) You can read more about MicroPython random functions here To use the random function we first need to import the function from the library: 1 from urandom import randint Here is a sample loop that sets each pixel to a random color using the wheel() function: 1 2 3 4 5 for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 ) Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 ) Exercises Instead of updating a single pixel in consecutive sequences, can you also use the randint() function to update a random pixel? What if you have a small fixed list of colors to pick from. How can you use randint() to pick a color from this list?","title":"Random"},{"location":"lessons/15-random/#random-drawing","text":"In this lesson we will introduce the ability to draw random colors at random pixels. This allows us to create more natural patterns such as the flicking light of a candle.","title":"Random Drawing"},{"location":"lessons/15-random/#the-random-functions","text":"We need a function that will generate a random integer between a range of values. This is called the randint() function and it takes either one or two parameters. In our case, we can just pass in the minimum and maximum values: 1 randint ( 0 , 256 ) You can read more about MicroPython random functions here To use the random function we first need to import the function from the library: 1 from urandom import randint Here is a sample loop that sets each pixel to a random color using the wheel() function: 1 2 3 4 5 for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 )","title":"The Random Functions"},{"location":"lessons/15-random/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 )","title":"Full Program"},{"location":"lessons/15-random/#exercises","text":"Instead of updating a single pixel in consecutive sequences, can you also use the randint() function to update a random pixel? What if you have a small fixed list of colors to pick from. How can you use randint() to pick a color from this list?","title":"Exercises"},{"location":"lessons/16-candle/","text":"Candle Flicker In this lesson we will try to simulate the behavior of a flickering candle using the randint() function. To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary. This will give the impression of a candle flame with a flicker. A pure yellow color has both the red and green values on and the blue value off: 1 2 yellow = ( 255 , 255 , 0 ) orange = ( 255 , 150 , 0 ) Our goal is to generate variations in both color and brightness. We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50. Sample Candle Function Our function will draw the new value on a random location on the LED strip. It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second. 1 2 3 4 5 6 7 def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) Full Demonstration Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint # https://docs.micropython.org/en/latest/library/random.html NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) counter = 0 while True : candle ( . 01 ) # wrap counter = counter % ( NUMBER_PIXELS - 1 ) counter += 1","title":"Candle Flicker"},{"location":"lessons/16-candle/#candle-flicker","text":"In this lesson we will try to simulate the behavior of a flickering candle using the randint() function. To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary. This will give the impression of a candle flame with a flicker. A pure yellow color has both the red and green values on and the blue value off: 1 2 yellow = ( 255 , 255 , 0 ) orange = ( 255 , 150 , 0 ) Our goal is to generate variations in both color and brightness. We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50.","title":"Candle Flicker"},{"location":"lessons/16-candle/#sample-candle-function","text":"Our function will draw the new value on a random location on the LED strip. It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second. 1 2 3 4 5 6 7 def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay )","title":"Sample Candle Function"},{"location":"lessons/16-candle/#full-demonstration-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint # https://docs.micropython.org/en/latest/library/random.html NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) counter = 0 while True : candle ( . 01 ) # wrap counter = counter % ( NUMBER_PIXELS - 1 ) counter += 1","title":"Full Demonstration Program"},{"location":"lessons/17-theater-chase/","text":"Theater Chase Theater Chase is a classic pattern that was popularized in marquee signs above movie theaters. It consists of a row of lights that were usually switched on and off so it would appear that the lights were moving or being chased around the edge of the signs. Sample Theater Chase Function To create the illusion of pixels moving along a strip, we need to have three nested loops: The inner \"i\" loop just moves from 0 to the number of pixels in steps of 3 (or a similarly small number). It turns every 3rd pixel on, waits and then turns it off The middle \"q\" loop just offsets the starting point of the inner loop moving from values of 0, 1 and 2. The index in the inner loop is i+q . The outer-most \"j\" loop just indicates how many times the pattern should be repeated Here is a sample of the theater_chase function that has four parameters: the LED strip the color the delay (about 50 milliseconds) the number of times the pattern should be repeated (iterations) 1 2 3 4 5 6 7 8 9 10 11 12 def theater_chase ( strip , color , wait_ms = 50 , iterations = 10 ): for j in range ( iterations ): for q in range ( 3 ): # turn every third pixel on for i in range ( 0 , strip . numPixels (), 3 ): strip [ i + q ] = color strip . write () # keep the pixels on for a bit like 1/20th of a second sleep_ms ( wait_ms ) # turn every third pixel off for i in range ( 0 , strip . numPixels (), 3 ): strip . setPixelColor ( i + q , 0 ) If you want to lower the power of the LED strip, you can change the skip number in the inner loop from 3 to 4, 5 or 6 etc. Full Program This program will run a theater chase for the seven colors of the rainbow and then repeat. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def theater_chase ( strip , color , wait_ms = 50 , iterations = 10 ): for j in range ( iterations ): for q in range ( 3 ): for i in range ( 0 , strip . numPixels (), 3 ): strip [ i + q ] = color strip . write () sleep_ms ( wait_ms ) for i in range ( 0 , strip . numPixels (), 3 ): strip . setPixelColor ( i + q , 0 ) while True : # iterate through all the colors for c in range ( 0 , num_colors ): theater_chase ( strip , colors [ c ], wait_ms = 50 , iterations = 50 ) Exercises Add the skip number as an additional parameter to the function Add another parameter that reversed the direction of the movement Create a function that randomly changes the direction every few seconds","title":"Theater Chase"},{"location":"lessons/17-theater-chase/#theater-chase","text":"Theater Chase is a classic pattern that was popularized in marquee signs above movie theaters. It consists of a row of lights that were usually switched on and off so it would appear that the lights were moving or being chased around the edge of the signs.","title":"Theater Chase"},{"location":"lessons/17-theater-chase/#sample-theater-chase-function","text":"To create the illusion of pixels moving along a strip, we need to have three nested loops: The inner \"i\" loop just moves from 0 to the number of pixels in steps of 3 (or a similarly small number). It turns every 3rd pixel on, waits and then turns it off The middle \"q\" loop just offsets the starting point of the inner loop moving from values of 0, 1 and 2. The index in the inner loop is i+q . The outer-most \"j\" loop just indicates how many times the pattern should be repeated Here is a sample of the theater_chase function that has four parameters: the LED strip the color the delay (about 50 milliseconds) the number of times the pattern should be repeated (iterations) 1 2 3 4 5 6 7 8 9 10 11 12 def theater_chase ( strip , color , wait_ms = 50 , iterations = 10 ): for j in range ( iterations ): for q in range ( 3 ): # turn every third pixel on for i in range ( 0 , strip . numPixels (), 3 ): strip [ i + q ] = color strip . write () # keep the pixels on for a bit like 1/20th of a second sleep_ms ( wait_ms ) # turn every third pixel off for i in range ( 0 , strip . numPixels (), 3 ): strip . setPixelColor ( i + q , 0 ) If you want to lower the power of the LED strip, you can change the skip number in the inner loop from 3 to 4, 5 or 6 etc.","title":"Sample Theater Chase Function"},{"location":"lessons/17-theater-chase/#full-program","text":"This program will run a theater chase for the seven colors of the rainbow and then repeat. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def theater_chase ( strip , color , wait_ms = 50 , iterations = 10 ): for j in range ( iterations ): for q in range ( 3 ): for i in range ( 0 , strip . numPixels (), 3 ): strip [ i + q ] = color strip . write () sleep_ms ( wait_ms ) for i in range ( 0 , strip . numPixels (), 3 ): strip . setPixelColor ( i + q , 0 ) while True : # iterate through all the colors for c in range ( 0 , num_colors ): theater_chase ( strip , colors [ c ], wait_ms = 50 , iterations = 50 )","title":"Full Program"},{"location":"lessons/17-theater-chase/#exercises","text":"Add the skip number as an additional parameter to the function Add another parameter that reversed the direction of the movement Create a function that randomly changes the direction every few seconds","title":"Exercises"},{"location":"lessons/18-ripple/","text":"Ripple Patterns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # moving rainbow from machine import Pin from neopixel import NeoPixel from utime import sleep , ticks_ms from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def ripple ( size , color , delay ): # start at a random location within size of the ends start = randint ( size , NUMBER_PIXELS - size ) for i in range ( 0 , size ): strip [ start + i ] = color strip [ start - i ] = color strip . write () sleep ( delay ) strip [ start + i ] = ( 0 , 0 , 0 ) strip [ start - i ] = ( 0 , 0 , 0 ) delay = 0.2 while True : ripple ( 10 , red , delay ) ripple ( 10 , green , delay ) ripple ( 10 , blue , delay ) Exercises Make the color random Make the size of the ripple random Add randomness to the delay Use the wheel function to pick a random color Make the pixel intensity get lower as the ripple expands","title":"Ripple"},{"location":"lessons/18-ripple/#ripple-patterns","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # moving rainbow from machine import Pin from neopixel import NeoPixel from utime import sleep , ticks_ms from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def ripple ( size , color , delay ): # start at a random location within size of the ends start = randint ( size , NUMBER_PIXELS - size ) for i in range ( 0 , size ): strip [ start + i ] = color strip [ start - i ] = color strip . write () sleep ( delay ) strip [ start + i ] = ( 0 , 0 , 0 ) strip [ start - i ] = ( 0 , 0 , 0 ) delay = 0.2 while True : ripple ( 10 , red , delay ) ripple ( 10 , green , delay ) ripple ( 10 , blue , delay )","title":"Ripple Patterns"},{"location":"lessons/18-ripple/#exercises","text":"Make the color random Make the size of the ripple random Add randomness to the delay Use the wheel function to pick a random color Make the pixel intensity get lower as the ripple expands","title":"Exercises"},{"location":"lessons/18-twinkle/","text":"Twinkle 1 2 3 4 5 6 7 8 9 def twinkle ( delay ): random_index = randint ( 0 , NUMBER_PIXELS ); # turn on strip [ random_index ] = ( 255 , 255 , 255 ) strip . write (); sleep ( delay ); # turn off strip [ random_index ] = ( 0 , 0 , 0 ) strip . write ();","title":"Twinkle"},{"location":"lessons/18-twinkle/#twinkle","text":"1 2 3 4 5 6 7 8 9 def twinkle ( delay ): random_index = randint ( 0 , NUMBER_PIXELS ); # turn on strip [ random_index ] = ( 255 , 255 , 255 ) strip . write (); sleep ( delay ); # turn off strip [ random_index ] = ( 0 , 0 , 0 ) strip . write ();","title":"Twinkle"},{"location":"lessons/19-larson-scanner/","text":"Larson Scanner The Larson Scanner is a light pattern special effect named after Glen A. Larson . Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience. See Knight Rider for the backstory. Description A set of usually red pixels moves back and forth over the LED strip. The pixels are brighter in the center and are dimmer at the edges of the set. You can see an example of this in the Larson Scanner Pumpkin Kit Color RGB values We will need a set of predefined colors for various brightness of red: 1 2 3 4 red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) Note that the color levels are not linear. You can adjust these and add more intermediate levels for wider patterns. Full Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # Larson Scanner - five pixels from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) delay = . 05 while True : # forward loop for i in range ( 2 , NUMBER_PIXELS - 2 ): strip [ i - 2 ] = red_light strip [ i - 1 ] = red_med strip [ i ] = red strip [ i + 1 ] = red_med strip [ i + 2 ] = red_light # erase the trailing pixel if i > 0 : strip [ i - 3 ] = off strip . write () sleep ( delay ) # backward loop for i in range ( NUMBER_PIXELS - 4 , 1 , - 1 ): # erase the trailing pixel if i < NUMBER_PIXELS - 2 : strip [ i + 3 ] = off strip [ i - 2 ] = red_light strip [ i - 1 ] = red_med strip [ i ] = red strip [ i + 1 ] = red_med strip [ i + 2 ] = red_light strip . write () sleep ( delay ) Exercises Turn the code into a function with delay as a patter Add a color parameter Add a parameter for the width of the pattern","title":"Larson Scanner"},{"location":"lessons/19-larson-scanner/#larson-scanner","text":"The Larson Scanner is a light pattern special effect named after Glen A. Larson . Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience. See Knight Rider for the backstory.","title":"Larson Scanner"},{"location":"lessons/19-larson-scanner/#description","text":"A set of usually red pixels moves back and forth over the LED strip. The pixels are brighter in the center and are dimmer at the edges of the set. You can see an example of this in the Larson Scanner Pumpkin Kit","title":"Description"},{"location":"lessons/19-larson-scanner/#color-rgb-values","text":"We will need a set of predefined colors for various brightness of red: 1 2 3 4 red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) Note that the color levels are not linear. You can adjust these and add more intermediate levels for wider patterns.","title":"Color RGB values"},{"location":"lessons/19-larson-scanner/#full-source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # Larson Scanner - five pixels from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) delay = . 05 while True : # forward loop for i in range ( 2 , NUMBER_PIXELS - 2 ): strip [ i - 2 ] = red_light strip [ i - 1 ] = red_med strip [ i ] = red strip [ i + 1 ] = red_med strip [ i + 2 ] = red_light # erase the trailing pixel if i > 0 : strip [ i - 3 ] = off strip . write () sleep ( delay ) # backward loop for i in range ( NUMBER_PIXELS - 4 , 1 , - 1 ): # erase the trailing pixel if i < NUMBER_PIXELS - 2 : strip [ i + 3 ] = off strip [ i - 2 ] = red_light strip [ i - 1 ] = red_med strip [ i ] = red strip [ i + 1 ] = red_med strip [ i + 2 ] = red_light strip . write () sleep ( delay )","title":"Full Source Code"},{"location":"lessons/19-larson-scanner/#exercises","text":"Turn the code into a function with delay as a patter Add a color parameter Add a parameter for the width of the pattern","title":"Exercises"},{"location":"lessons/20-clock/","text":"Clock Can you turn your LED strip into a clock? You can use binary encoding to display the numbers in a clock. To do this we will need a function to display a digit as a binary pattern.","title":"Clock"},{"location":"lessons/20-clock/#clock","text":"Can you turn your LED strip into a clock? You can use binary encoding to display the numbers in a clock. To do this we will need a function to display a digit as a binary pattern.","title":"Clock"}]}