{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the MicroPython Moving Rainbow Website!","text":""},{"location":"#about-the-moving-rainbow-project","title":"About the Moving Rainbow Project","text":"<p>Moving Rainbow is a way to learn the basics of programming using LED strips.  We use low-cost components so you can build entire projects and costumes with 100s of LEDs for under $20.  Since 2014 we have been building low-cost kits that teach all the concepts of Computational Thinking](https://www.coderdojotc.org/CoderDojoTC/computational-thinking/).</p> <p>Note</p> <p>We are no longer accepting pull requests for Arduino C code.  Because we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Our getting started guide has three parts:</p> <ol> <li>About Moving Rainbow</li> <li>Code Savvy Kits</li> <li>Build Your Own from Parts</li> <li>Desktop Setup</li> </ol>"},{"location":"#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>The Raspberry Pi Pico cost only $4 and runs Python.  All our labs use this processor.</p>"},{"location":"#breadboards","title":"Breadboards","text":"<p>In our projects we use 1/2 sized breadboard with 400 tie points.</p> <p></p>"},{"location":"#mode-buttons","title":"Mode Buttons","text":"<p>A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip.  Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program.</p> <p>In this section we will add two mode buttons.  One button will make the pattern mode go to the next mode.  The other button will go to the previous mode.</p>"},{"location":"#programming-the-led-strip","title":"Programming the LED strip","text":"<p>Each of our example programs will have at least three sections:</p> <ol> <li>The preamble - this constains the library directives and initialization of static unchanging variables</li> <li>The setup() function - this function is run once with the Arduion first starts up</li> <li>The loop function - this function runs continually as long at the Arduino has power</li> </ol> <p>Sample Blink Program</p>"},{"location":"challenges-v2/","title":"Challenges for Python LED Exercises","text":""},{"location":"challenges-v2/#1-blinkpy","title":"1. Blink.py","text":""},{"location":"challenges-v2/#a-original-intent","title":"a. Original intent:","text":"<ul> <li>Understand the \u201cstrip[0]\u201d position</li> <li>Understand RGB numbering</li> <li>Understand \u201csleep(1)\u201d (1 = seconds)</li> <li>Introduce \u201cwhile True:\u201d looping concept</li> </ul>"},{"location":"challenges-v2/#b-challenge","title":"b. Challenge:","text":"<ul> <li>Select a different position</li> <li>Select a different color</li> <li>Select a different delay</li> </ul>"},{"location":"challenges-v2/#2-red-green-bluepy","title":"2. Red-green-blue.py","text":""},{"location":"challenges-v2/#a-original-intent_1","title":"a. Original intent:","text":"<ul> <li>Reinforce above concepts</li> </ul>"},{"location":"challenges-v2/#b-challenge_1","title":"b. Challenge:","text":"<ul> <li>Change brightness</li> <li>Make lights blink (turn off) before changing colors</li> <li>Add new colors (blending RGB)</li> </ul>"},{"location":"challenges-v2/#3-dimmerpy","title":"3. Dimmer.py","text":""},{"location":"challenges-v2/#a-original-intent_2","title":"a. Original intent:","text":"<ul> <li>Reinforce above</li> <li>Introduce \u2018stepping\u2019 parameter in for loop, and thus the concept of counting backwards</li> </ul>"},{"location":"challenges-v2/#b-challenge_2","title":"b. Challenge:","text":"<ul> <li>Select a different rate at which to increase and decrease brightness (different step value) \u2013 light up only the even-numbered LEDs (or odd)</li> <li>Have different lights dim/brighten \u2013 make each of the lights in the strip brighten/dim in sequence</li> </ul>"},{"location":"challenges-v2/#4-movepy","title":"4. Move.py","text":""},{"location":"challenges-v2/#a-original-intent_3","title":"a. Original intent:","text":"<ul> <li>Reinforce above</li> <li>Introduce config.NUMBER_PIXELS &amp; using that to control the end of loop</li> <li>Note that NUMBER_PIXELS indicates the quantity of LEDs in the strip, but that the LEDs are indexed/identified starting with 0</li> </ul>"},{"location":"challenges-v2/#b-challenge_3","title":"b. Challenge:","text":"<ul> <li>Make the move backwards (well .. this is done in the next exercise)</li> <li>Illuminate every third LED on the strip</li> <li>Make the lights appear to \u201crun faster\u201d backwards than forwards</li> </ul>"},{"location":"challenges-v2/#5-up-and-downpy","title":"5. Up-and-down.py","text":""},{"location":"challenges-v2/#a-original-intent_4","title":"a. Original intent:","text":"<ul> <li>Reinforce above</li> </ul>"},{"location":"challenges-v2/#b-challenge_4","title":"b. Challenge:","text":"<ul> <li>See challenges in Move.py</li> </ul>"},{"location":"challenges-v2/#6-color-wipepy","title":"6. Color-wipe.py","text":""},{"location":"challenges-v2/#a-original-intent_5","title":"a. Original intent:","text":"<ul> <li>Reinforce above</li> </ul>"},{"location":"challenges-v2/#b-challenge_5","title":"b. Challenge:","text":"<ul> <li>Make it so that the entire strip seems to change from R to G to B at once</li> <li>Make a stop light \u2013 top 1/3 = red, mid = yellow, lower 1/3 = green</li> </ul>"},{"location":"challenges-v2/#7-randompy","title":"7. Random.py","text":""},{"location":"challenges-v2/#a-original-intent_6","title":"a. Original intent:","text":"<ul> <li>Reminder about \u201crandint\u201d function</li> <li>Reinforce RGB, looping</li> </ul>"},{"location":"challenges-v2/#b-challenge_6","title":"b. Challenge:","text":"<ul> <li>Have two LEDs lit at the same time, one randomly in the lower half of the strip and one in the upper half.</li> <li>Have two LEDs lit at the same time, each the same random distance from the center point</li> </ul>"},{"location":"challenges-v2/#8-color-wheelpy","title":"8. Color-wheel.py","text":""},{"location":"challenges-v2/#a-original-intent_7","title":"a. Original intent:","text":"<ul> <li>Reminder about creating functions</li> <li>Use of \u201creturn\u201d</li> </ul>"},{"location":"challenges-v2/#b-challenge_7","title":"b. Challenge:","text":"<ul> <li>Either make entire strip become a color wheel</li> <li>Or \u2026 make each LED in the strip become a color wheel, one by one with a slight pause between</li> </ul>"},{"location":"challenges-v2/#9-rainbowpy","title":"9. Rainbow.py","text":""},{"location":"challenges-v2/#a-original-intent_8","title":"a. Original intent:","text":"<ul> <li>Reinforce functions/return</li> </ul>"},{"location":"challenges-v2/#b-challenge_8","title":"b. Challenge:","text":"<ul> <li>Make it build rainbow backwards (so end result is VIBGYOR)</li> </ul>"},{"location":"challenges-v2/#10-rainbow-cyclepy","title":"10. Rainbow-cycle.py","text":""},{"location":"challenges-v2/#a-original-intent_9","title":"a. Original intent:","text":"<ul> <li>More of rainbow.py, but moving in continuous loop</li> </ul>"},{"location":"challenges-v2/#b-challenge_9","title":"b. Challenge:","text":"<ul> <li>Make it cycle forwards, then backwards</li> </ul>"},{"location":"challenges/","title":"Moving Rainbow Challenges","text":"<p>They are a set of learning challenges for the LED Strip.  They are listed in order from the simplest to the most complex.</p>"},{"location":"challenges/#beginning-challenges","title":"Beginning Challenges","text":"<p>These challenges can all be done once you know the following commands:</p> <ol> <li>Initialize the NeoPixel</li> <li>Change a Pixel Color</li> <li>Write the Strip</li> <li>For Loop and range</li> <li>Sleep</li> </ol>"},{"location":"challenges/#make-a-pixel-blink","title":"Make a Pixel Blink","text":""},{"location":"challenges/#draw-an-rgb-pattern","title":"Draw an RGB Pattern","text":""},{"location":"challenges/#draw-a-rainbow","title":"Draw a Rainbow","text":""},{"location":"challenges/#make-a-pixel-fade-in-and-out-slowly","title":"Make a Pixel Fade in and Out Slowly","text":""},{"location":"challenges/#make-a-heartbeat-pattern","title":"Make a Heartbeat Pattern","text":""},{"location":"challenges/#make-a-pixel-move-down-the-strip","title":"Make a Pixel Move Down the Strip","text":""},{"location":"challenges/#change-colors-for-the-entire-led-strip-wipe","title":"Change Colors for the Entire LED Strip (wipe)","text":""},{"location":"challenges/#move-a-pixel-down-and-back","title":"Move a Pixel Down and Back","text":""},{"location":"challenges/#create-a-larson-scanner-pattern","title":"Create a Larson Scanner Pattern","text":""},{"location":"challenges/#draw-different-levels-of-brightness","title":"Draw Different Levels of Brightness","text":""},{"location":"challenges/#make-every-other-pixel-a-different-color","title":"Make Every Other Pixel a Different Color","text":""},{"location":"challenges/#intermediate-labs","title":"Intermediate Labs","text":"<p>These challenges involve more advanced programming such as using:</p> <ol> <li>Conditionals</li> <li>Modulo (remainder)</li> <li>Functions</li> <li>Multiple Loops</li> <li>Nested Loops</li> <li>Lists</li> <li>Random Numbers</li> </ol>"},{"location":"challenges/#move-the-rainbow-pattern","title":"Move the Rainbow Pattern","text":""},{"location":"challenges/#move-a-comet-pattern","title":"Move a Comet Pattern","text":""},{"location":"challenges/#create-a-list-of-named-colors","title":"Create a List of Named Colors","text":""},{"location":"challenges/#create-a-theater-chase-pattern","title":"Create a Theater Chase Pattern","text":""},{"location":"challenges/#use-the-wheel-function-to-draw-a-rainbow","title":"Use The Wheel Function to Draw a Rainbow","text":""},{"location":"challenges/#do-a-color-cycle-for-the-entire-strip","title":"Do a Color Cycle for the Entire Strip","text":""},{"location":"challenges/#draw-multiple-color-comets","title":"Draw Multiple Color Comets","text":""},{"location":"challenges/#draw-different-patterns-in-a-loop","title":"Draw Different Patterns in a Loop","text":""},{"location":"challenges/#use-random-numbers-for-color-selection","title":"Use Random Numbers for Color Selection","text":""},{"location":"challenges/#random-ripples","title":"Random Ripples","text":"<p>Draw random ripple patterns on the LED strips where the pixels move out from a single point.</p>"},{"location":"challenges/#use-random-to-simulate-candle-flicker","title":"Use Random to Simulate Candle Flicker","text":""},{"location":"challenges/#use-random-to-for-changing-move-direction","title":"Use Random to For Changing Move Direction","text":""},{"location":"challenges/#advanced-labs","title":"Advanced Labs","text":"<p>These labs may require some additional components such as:</p> <ol> <li>Buttons (momentary press)</li> <li>Potentiometers</li> <li>Speaker/Buzzer</li> <li>Interrupt Service Routines</li> <li>A USB Current Meter</li> <li>A Light Sensor (photoresistor)</li> <li>An OLED display</li> <li>A Wireless Controller</li> </ol>"},{"location":"challenges/#create-separate-python-functions-for-five-patterns","title":"Create Separate Python Functions for Five Patterns","text":""},{"location":"challenges/#create-a-mode-variable-for-switching-the-patterns","title":"Create a Mode Variable for Switching the Patterns","text":""},{"location":"challenges/#use-a-button-to-change-a-pattern-mode","title":"Use a Button to Change a Pattern Mode","text":""},{"location":"challenges/#night-light","title":"Night Light","text":"<p>Add a photoresistor that will turn the LED strip on when it is dark in the room.</p>"},{"location":"challenges/#use-potentiometers-to-change-speed","title":"Use Potentiometers to Change Speed","text":"<p>Add a potentiometer and change the speed of a display pattern</p>"},{"location":"challenges/#use-potentiometers-to-change-brightness","title":"Use Potentiometers to Change Brightness","text":"<p>Add a potentiometer and change the brightness of a display pattern</p>"},{"location":"challenges/#create-a-demo-auto-cycle-pattern-a-button-to-advance-the-mode","title":"Create a Demo Auto-Cycle Pattern a Button to Advance the Mode","text":""},{"location":"challenges/#calculate-the-power-draw-of-different-colors","title":"Calculate the Power Draw of Different Colors","text":"<p>Get a USB power meter from the instructor.  Measure the current draw for each of the different colors.  Calculate the time for a 2,500-milliamp-hour battery pack for various patterns.</p>"},{"location":"challenges/#connect-an-oled-display-that-shows-the-pattern-color-and-brightness-of-the-led-strip","title":"Connect an OLED display that shows the pattern, color and brightness of the LED strip.","text":""},{"location":"challenges/#add-buttons-to-change-the-parameters-with-the-oled","title":"Add Buttons to Change the Parameters with the OLED","text":""},{"location":"challenges/#add-a-sound","title":"Add a Sound","text":"<p>Add a speaker or buzzer to play a sound when a button is pressed.</p>"},{"location":"challenges/#simon-game","title":"Simon Game","text":"<p>Display a pattern on four pixels of the LED strip and have the user repeat the pattern using four buttons.  Play different tones for each pixel.</p>"},{"location":"challenges/#zone-game","title":"Zone Game","text":"<p>Draw a zone of a different color in the center of the strip.  Move a pixel down and strip and give a player a point if they press the button in the strip.  Use sound and pixel colors to show the points score.  Make the zone smaller and the speed faster as the game progresses.</p>"},{"location":"challenges/#random-zone","title":"Random Zone","text":"<p>Add randomization to your Zone game to make the zone move in random directions.</p>"},{"location":"challenges/#clock","title":"Clock","text":"<p>Turn your LED strip into a clock.  You can display each digit using a binary structure.</p>"},{"location":"challenges/#wireless-labs","title":"Wireless Labs","text":""},{"location":"challenges/#web-page-color-control","title":"Web Page Color Control","text":"<p>Create a web page that changes the color of the LED strip.</p>"},{"location":"challenges/#create-a-web-page-to-change-the-pattern","title":"Create a Web Page to Change the Pattern","text":"<p>Create a web page that changes the pattern</p>"},{"location":"challenges/#pattern-brightness-and-speed","title":"Pattern, Brightness and Speed","text":"<p>Create a web page that changes the pattern, brightness and speed of a pattern.</p>"},{"location":"challenges/#display-the-weather-forecast","title":"Display the Weather Forecast","text":"<p>Use a web service to get the weather forecast for the current day. Change the color of the display:</p> <ol> <li>Yellow for Sunny</li> <li>Gray for Cloudy</li> <li>Red for Rain</li> <li>White for Snow</li> </ol> <p>You can use this example to get started.</p>"},{"location":"glossary/","title":"Moving Rainbow Glossary of Terms","text":""},{"location":"glossary/#github-pages","title":"GitHub Pages","text":""},{"location":"glossary/#deep-linking","title":"Deep Linking","text":""},{"location":"glossary/#markdown","title":"Markdown","text":""},{"location":"glossary/#neopixel","title":"NeoPixel","text":""},{"location":"glossary/#raspberry-pi-foundation","title":"Raspberry Pi Foundation","text":""},{"location":"glossary/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":""},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#basic-requirements","title":"Basic Requirements","text":"<ol> <li>Hosting the site must be free using GitHub Pages</li> <li>We need to document the Python sample code</li> <li>We want professional-quality code highlighting</li> <li>We wanted the site to have a strong search function</li> <li>We wanted to make it easy to generate the HTML from easy-to-edit Markdown files</li> <li>We wanted to make it easy for an instructor to copy the link from any section of any lesson plan directly into a Zoom/Chat window so students can just click on the link to get the right lesson.  This is called Deep Linking</li> <li>We wanted to make it easy to build user interfaces that are consistent with our other projects including:<ol> <li>Beginning Python</li> <li>Beginning Electronics</li> <li>MicroPython for Kids</li> <li>Robot Faces</li> <li>Clocks and Watches</li> <li>Robot Day</li> <li>STEM Robots</li> <li>MicroSims for Education</li> <li>Digital Electronics</li> </ol> </li> <li>We wanted to make it easy for other schools and organizations to just \"fork\" this repository to put their own school logo and colors on the site.</li> <li>We wanted to leverage existing GitHub tools for reporting bugs, organizing projects and tasks and automating the build process.</li> <li>We wanted to make sure we would support consistent build and release management so we could add new features without disrupting existing sites. (branches, tagging and release).</li> <li>We wanted to paste a link on a social media site or a chat like Zoom or Slack and have a nice \"Social Media\" card to display information about that lesson.</li> </ol>"},{"location":"how-we-built-this-site/#why-python-mkdocs","title":"Why Python Mkdocs","text":"<p>The goal of this site is to teach computational thinking  in the coolest hands-on way we can think of. We also do this by using AI to help us find the lowest-cost parts.</p> <p>We also leverage open-source MicroPython, and it is natural to want to use a website builder that also uses Python. Python is language of data science and AI.  So we wanted to create a site that could be familiar to Python developers.</p> <p>But we also wanted to make it easy for non-programmers to update the site.  Let's review some of these design decisions and explain how you can \"fork\" this site (duplicate it) and put your school or organization's brand and logo on the pages</p> <p>We will also touch a little bit on how we are using Google Analytics to track site usage and how this can be added with just a few new lines in the configuration file for this site.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#enable-edit-icon","title":"Enable Edit Icon","text":"<p>To enable the Edit icon on all pages, you must add the edit_uri and the content.action.edit under the theme features area.</p> <pre><code>edit_uri: edit/master/docs/\n</code></pre> <pre><code>    theme:\n        features:\n            - content.action.edit\n</code></pre> <p>See the Mkdocs Material documentation.</p>"},{"location":"how-we-built-this-site/#github-action-to-deploy-after-edit","title":"GitHub Action to Deploy After Edit","text":"<p>We want to allow non-technical staff to click the \"Edit\" button on the pages and just click the \"Save\".  This should trigger the Markdown to HTML conversion and rebuild the site.</p> <p>GitHub Action for Mkdocs Deply</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"resources/","title":"Moving Rainbow Resources","text":""},{"location":"resources/#micropython-documentation-on-neopixels","title":"MicroPython Documentation on NeoPixels","text":"<ul> <li>MicroPython NeoPixel Tutorial - note this is in the esp8266 area but it will run on the Raspberry Pi Pico without change.</li> <li>MicroPython NeoPixel Library - note, that there are errors in this documentation.  You do not need to reference the machine type.</li> </ul>"},{"location":"resources/#references","title":"References","text":"<ol> <li>CodeSavvy</li> <li>CoderDojo International</li> <li>CoderDojo Twin Cities (now part of the Code Savvy Explorer Program)</li> </ol>"},{"location":"getting-started/about/","title":"About Moving Rainbow","text":"<p>What is the lowest-cost and most fun kit that teaches computational thinking?  This is the question that has been the driving force behind the Moving Rainbow project.</p> <p>We think the answer is the $10 Moving Rainbow kit.  Let us tell you why.</p>"},{"location":"getting-started/about/#background-of-the-moving-rainbow","title":"Background of the Moving Rainbow","text":"<p>In 2014 the IoT Hackday program in Minnesota was looking for a way to introduce new students to the Internet of Things and to teach computer programming with microcontrollers.  Dan McCreary developed a series of projects and tried them on in classrooms.  He quickly learned that kids loved working with LEDs and making colorful patterns with rows of LEDs.</p> <p>However, these projects required lots of individual components (LEDs, resistors, Arduino etc.).  Eventually, Dan discovered a new type of LEDs that came in long strips and each pixel contained an individually addressable red, green and blue pixel.  These projects were easy to hook up and the students could focus on programming the patterns on the LED strips.</p> <p>Dan's first \"kits\" contained an Arduino Nano and only 12 pixels.  But he could provide the kits to teachers, mentors, and students for under $25.  Since then the cost of both the microcontrollers and the LED strips have come down.  And since 2021 the curriculum has shifted from C on Arduino to Python on Picos and similar powerful but low-cost microcontrollers.</p> <p>Today, the Moving Rainbow systems include kits, instructions for building your own kits and extensive lesson plans on both the Pico and the Pico \"W\" (wireless).</p>"},{"location":"getting-started/about/#color-motion-fun-and-design","title":"Color, Motion, Fun and Design","text":"<p>So why pick this specific design?  At the center of this design is hundreds of hours of careful observation of students actually using these devices.  With each iteration, we continue to build, test, observe and change our design to meet the needs of our students.  Here is what we have learned:</p> <ol> <li>Kids love color</li> <li>Kids love motion</li> <li>Kids love to have their OWN devices to show their friends and family.  </li> </ol> <p>If they can take them home and show them off they take ownership of the skills they need to continually create and expand the features of these little devices.</p> <p>These principles are simple, but they are well-tested and we think they will persist even as technology progresses.  We expect to have more powerful devices and bigger and better displays.  But the stepping stones will remain.</p>"},{"location":"getting-started/about/#licenses","title":"Licenses","text":"<p>All Moving Rainbow curricula are licensed under Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0).  This means you can use and modify the materials in your classroom as long as you don't resell the content for profit.</p>"},{"location":"getting-started/about/#contact","title":"Contact","text":"<p>If you have further questions about the Moving Rainbow Project by contacting Dan on his LinkedIn page.  We are continually looking for schools, teachers, mentors and students that would like to promote computational thinking in our classrooms and at home.</p>"},{"location":"getting-started/connections/","title":"Circuit Connections","text":"<p>Because this guide is focused on teaching computational thinking, we don't spend much time on circuits and wiring diagrams.  We try to keep the circuits and wiring diagrams as simple as possible.</p> <p>For the basic NeoPixel strip are only three wires you need to connect only three wired for the basic project.</p> <ol> <li>The LED strip GND </li> <li>The LED strip power (+5)</li> <li>The LED strip data</li> </ol> <p></p>"},{"location":"getting-started/desktop-setup/","title":"Desktop Setup","text":"<p>In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE).  We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.</p>"},{"location":"getting-started/desktop-setup/#about-thonny","title":"About Thonny","text":"<p>Thonny is an ideal tool for writing MicroPython code for students just getting started.  It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.</p>"},{"location":"getting-started/desktop-setup/#step-1-install-thonny","title":"Step 1: Install Thonny","text":"<p>The installation of Thonny will vary depending on the type of computer you are using.  For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page:</p> <p></p> <p>For all the versions of Linux, you can open the command shell and type in the correct installation command.  For people using the Raspberry Pi operating system, Thonny may already be included in your software.</p>"},{"location":"getting-started/desktop-setup/#thonny-versions","title":"Thonny Versions","text":"<p>These screen images were done with Thonny Version 4.0.4.  We also tested the steps on Thonny version 4.1.2 and the seem to work fine.</p>"},{"location":"getting-started/desktop-setup/#step-2-configure-the-micropython-firmware","title":"Step 2: Configure the MicroPython Firmware","text":"<p>After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico.  This just takes a minute and you will only have to do it once for each microcontroller.</p> <p>Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.</p>"},{"location":"getting-started/desktop-setup/#manually-downloading-the-firmware","title":"Manually Downloading the Firmware","text":"<p>There are occasions when the automatic firmware download in Thonny may not work.  In this case, you will need to manually download the firmware from the MicroPython website.</p> <p>Here are the links to the Pico Firmware (called RP2-pico):</p> <p>Raspberry Pi Pico Firmware</p> <p></p>"},{"location":"getting-started/desktop-setup/#step-3-configure-interpreter","title":"Step 3: Configure Interpreter","text":"<p>Thonny is designed to automatically detect the correct device and configure the right interpreter.  You can verify this by using the Thonny Tools -&gt; Options menu and move to the Interperter tab.</p> <p></p> <p>Note that the MicroPython (Raspberry Pi Pico) is selected.</p>"},{"location":"getting-started/desktop-setup/#thonny-firmware-list","title":"Thonny Firmware List","text":"<p>You can also get a list of all the different versions of firmware by going directly to the MicroPython site.  Here is what that list will look like:</p> <p></p> <p>After you select a runtime version, Thonny will give you the details about this version.</p> <p></p> <p></p> <p>After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware.  This makes the USB drive appear to be removed without a disconnect and results in an error.  This is normal so don't worry.</p> <p></p> <p></p>"},{"location":"getting-started/desktop-setup/#debugging-tips","title":"Debugging Tips","text":"<p>When debugging your Thonny installation, it is important to understand the steps that happen when you plug your Raspberry Pi Pico into the computer.</p> <p>Step 1: Plugging the USB Device The Pico appears as a USB device on your computer when you plug it in.  The operating system should send a request to the USB device asking it for its ID.</p> <p>Step 2: Probing for the USB ID The Pico will respond with a device ID number.  This number reflects two items: the company that made the device (Vendor ID) and the device product type (Product ID).  If you are using a power-only USB cable this number will never get to the operating system.  This means that the data wires are not present in your USB cable or one of the wires is broken or not connecting.</p> <p>Step 3: Looking Up the USB Driver The operating system will take this USB ID and then look-up the right software and then run that software.  In UNIX and Mac systems this will amount to making the USB device appear in the <code>/dev/cu*</code> area.  On Windows it will be a COM port.</p> <pre><code>ls -l /dev/cu.usb*\n\ncrw-rw-rw-  1 root  wheel  0x9000001 Dec 25 08:41 /dev/cu.usbmodem101\n</code></pre> <p>Note that the exact port name might change.  The example above is <code>cu.usbmodem101</code>.</p> <p>If this device does not immediately appear, then you should double-check your cable and make sure the operating system registers the USB device.</p> <p>If you know your cable works fine by testing it on other devices then you may have to reboot your computer.</p>"},{"location":"getting-started/desktop-setup/#automatic-power-draw-shutoff","title":"Automatic Power Draw Shutoff","text":"<p>If your USB port is drawing too much power, then many computers will disable the port.  This can happen if you are trying to display too many LEDs or a motor.  You will see a message such as \"USB Port Disabled\". </p> <p>Your computer manufacturer will tell you what the maximum current each USB port allows.  This is typically about 1 amp, but it varies based on your computer and what other devices are connected to your computer.</p> <p>The best way to debug this is to purchase a low-cost USB current monitor and monitor how much current your project is using.  If you are using an LED-strip then make sure you test the current with all the pixels fully on (255,255,255).</p> <p>USB Current Monitor Search on eBay</p> <p>In general, each NeoPixel at full brightness will draw up to 20 milliamps and the Pico will also draw about 20  milliamps.</p> <p>For projects that require more than about 500 milliamps, it is strongly recommended that you use an externally powered USB hub.</p>"},{"location":"getting-started/desktop-setup/#debugging-the-usb-port","title":"Debugging the USB Port","text":""},{"location":"getting-started/desktop-setup/#mac-system-profiler","title":"Mac System Profiler","text":"<p>On MacOS we can use the <code>system_profiler</code> command:</p> <pre><code>system_profiler SPUSBDataType\n\nUSB:\n\n    USB 3.1 Bus:\n\n      Host Controller Driver: AppleT8112USBXHCI\n\n    USB 3.1 Bus:\n\n      Host Controller Driver: AppleT8112USBXHCI\n\n        Board in FS mode:\n\n          Product ID: 0x0005\n          Vendor ID: 0x2e8a\n          Version: 1.00\n          Serial Number: e66141040396962a\n          Speed: Up to 12 Mb/s\n          Manufacturer: MicroPython\n          Location ID: 0x00100000 / 1\n          Current Available (mA): 500\n          Current Required (mA): 250\n          Extra Operating Current (mA): 0\n</code></pre> <p>Note that you can see both the Product ID, Vendor ID Manufacturer (MicroPython) and the mode (File System mode) that the device was connected.  The current available and current required are also listed, although these numbers might be somewhat conservative.  They are used for the estimation of current only.</p>"},{"location":"getting-started/desktop-setup/#checking-out-the-moving-rainbow-code-from-github","title":"Checking out the Moving Rainbow Code from GitHub","text":"<p>You don't need to copy and paste the code samples one-by-one into your local file system.  GitHub allows you to download all the code on the Moving Rainbow site by running the following command:</p> <pre><code># create a projects area to checkout your code\nmkdir ~/projects\ncd projects\n# make a copy of the repo on your local hard drive\ngit clone https://github.com/dmccreary/moving-rainbow\ncd moving-rainbow\n# open the files in your file manager\nopen .\n</code></pre> <p>You can now go directly to the source for the LED strip labs that have two buttons:</p> <pre><code>cd src/led-strip-two-buttons\n</code></pre> <p>Once you have done this step you can make the top Files region of Thonny point to the source area and then click the upper right corner that has the \"Upload to /\" menu.  Make sure the bottom area is set to the root, not the /lib area.</p> <p>The following video shows these steps:</p>"},{"location":"getting-started/desktop-setup/#understanding-thonny-and-file-systems","title":"Understanding Thonny and File Systems","text":"<p>To understand how Thonny works, we want to have a clear visual picture of the two parallel file systems that Thonny uses.</p> <ol> <li>Thonny is launched from your desktop or laptop computer.  The Files window at the top will always be open to that file system.</li> <li>Thonny also displays the file system on the microcontroller on the bottom window.  It displays this window after you successfully connect through the correct port.</li> </ol> <p>You can run a program in Thonny from either file system.  But there is one strict rule.  If you</p>"},{"location":"getting-started/github-summary/","title":"Moving Rainbow GitHub Summary","text":"<p>We like to keep things simple, or at least as simple as possible.  To allow our participants to get our source code and then make changes that are added, there are only six git commands that we need:</p> <ol> <li>clone - used to pull down the repo to your local computer</li> <li>pull - used to get updates from the GitHub repository</li> <li>add - add individual files to a local update package</li> <li>commit - wrap adds into a transaction package with a comment</li> <li>push - push your package up to the server</li> <li>status - get status on your local repository status</li> </ol>"},{"location":"getting-started/github-summary/#installing-git","title":"Installing Git","text":"<p>Before you begin, you will need to make sure that the git command line tools are working on your computer. You can find detailed installation instructions at the Git Book Chapter on Getting Started Installing Git.</p> <p>Note</p> <p>On a Mac you will get the following message the first time you try to run git for the first time.  This is normal.</p> <p>~</p>"},{"location":"getting-started/github-summary/#git-clone","title":"Git Clone","text":"<p>This command copies the latest version of our GitHub repository to your local file system.  Let's pull all our GitHub repositories together in a folder called \"projects\" off of our home directory.  This is called the tilde or \"~\" directory.</p> <p>Here is a sample shell script you can run</p> <pre><code># create a projects area to checkout your code\nmkdir ~/projects\ncd projects\n# make a copy of the repo on your local hard drive\ngit clone https://github.com/dmccreary/moving-rainbow\ncd moving-rainbow\n# open the files in your file manager\nopen .\n</code></pre>"},{"location":"getting-started/github-summary/#git-pull","title":"Git Pull","text":"<p>If you have been away from the project for a while, you will want to refresh your local code.  You can also do this if a co-worker has just made a change you wnat to include.</p> <pre><code>cd ~/projects/moving-rainbow\ngit pull\n</code></pre>"},{"location":"getting-started/github-summary/#git-add","title":"Git Add","text":"<p>After you have made local changes to the Moving Rainbow source code or documentation, you might want to set up a \"change set\" and share it with others.  You can create your own directory under the moving-rainbow/src area and add your new programs there.  Once you have done that you can run the following example:</p> <pre><code>cd ~/projects/moving-rainbow\nmkdir src/mycode\n# copy your new code to the src/mycode directory\ngit add src/mycode/*\n</code></pre> <p>You can keep doing this until your code is all tested.  Now you are read to commit the changes as a transaction.</p>"},{"location":"getting-started/github-summary/#git-commit","title":"Git Commit","text":"<p>In the last git add command we were just adding code without any comments.  Now we want to wrap all these changes up in a package and tell others why we are adding the code or making changes.  Here is that command:</p> <pre><code>git commit -m \"Adding my new sample patters\"\n</code></pre> <p>This command creates a package with a commit message. Your message should indicate why you are making the change. Git has great tools to tell you what lines changed, but it does not know why a change was made.  This is your job.</p> <p>Note that these changes are all collected locally.  The GitHub server has not yet been changed.</p>"},{"location":"getting-started/github-summary/#git-push","title":"Git Push","text":"<p>The final step is to push your package up to the central GitHub server.  This is done with a simple command:</p> <pre><code>git push\n</code></pre> <p>This should generate a dialog such as the following:</p> <pre><code>Enumerating objects: 7, done.\nCounting objects: 100% (7/7), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (4/4), 404 bytes | 404.00 KiB/s, done.\nTotal 4 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nTo https://github.com/dmccreary/moving-rainbow.git\n   efad633..68fdeae  master -&gt; master\n</code></pre> <p>If you have hundreds of large files or documentation with large images this step can take a few minutes.  It depends on how busy the servers are, what your ISP upload speed is and other factors such as network congestion.</p>"},{"location":"getting-started/github-summary/#checking-your-status","title":"Checking Your Status","text":"<p>After you are done, you can check your git status:</p> <pre><code>git status\n</code></pre> <p>This will return a text message such as:</p> <pre><code>On branch master\nYour branch is up to date with 'origin/master'.\n</code></pre>"},{"location":"getting-started/kits/","title":"Moving Rainbow Kits","text":"<p>These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip.  The total parts cost is typically under $10</p> <p></p>"},{"location":"getting-started/kits/#standard-parts","title":"Standard Parts","text":"<p>Our standard kit contains the following parts:</p> <ol> <li>Microcontroller - A Raspberry Pi Pico ($4) or \"W\" ($6).  We often solder our own headers in, but if you are not familiar with soldering you can purchase them with header pins soldered in place.</li> <li>Breadboard - A 1/2-size solderless breadboard (400 ties) ($2)</li> <li>LED Strip - A 60-LED/meter addressable RGB LED strip (WS2812B) ($4).  We purchase 1-meter strips and cut them in half and solder connectors on the ends.  You can also purchase NeoPixel rings, arrays and fairy lights.  Fairy lights are ideal for costumes but the thin wires are easily damaged.</li> <li>Headers - 3 terminal screw headers (optional) - This makes it easier to connect and disconnect the LED strip connections without soldering.</li> <li>Buttons - Two momentary push buttons.  We purchase these in packages of 100 to keep the per-button cost down.</li> <li>Wire - 22 gauge insulated wires.  We get red, black wire for power and ground and other colors for data.  We use yellow wire for the data connections.</li> <li>LED Strip Connectors - Many of the LED strips come with a somewhat standardized 3-pin connector.  This is often called a 3-pin SM JST connector.  It is designed so the users can't plug in the LED strip incorrectly.  Only about 1/2 of our current kits use these connectors.</li> </ol>"},{"location":"getting-started/kits/#optional-parts","title":"Optional Parts","text":""},{"location":"getting-started/kits/#usb-connectors","title":"USB Connectors","text":"<p>Most of our classrooms will also have the right USB cables for these boards.  If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector.</p>"},{"location":"getting-started/kits/#batteries-and-battery-packs","title":"Batteries and Battery Packs","text":"<p>If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones.  We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern)</p>"},{"location":"getting-started/kits/#led-strip-and-rings","title":"LED Strip and Rings","text":"<p>There are hundreds of variations of WS2812B LED strips and fairy lights.  We usually purchase them in 1-meter strips with 60 pixels per meter.  Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes.</p> <p>EBay Search for SW2812B</p> <p>If you are creating costumes that might get wet in the rain, we suggest getting the versions that are encased in a waterproof silicon tube or in a waterproof silicon coating.</p>"},{"location":"getting-started/kits/#led-fairy-lights","title":"LED Fairy Lights","text":""},{"location":"getting-started/parts/","title":"Purchasing LED Strip Parts","text":"<p>In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you.  Very often they will be pre-assembled and all the software preloaded before the classes begin.  This guide is for mentors, parents and students who would like to build personal systems at home.</p> <p>You can easily create personal projects based on the Moving Rainbow kits and software.  You can do this by purchasing parts on online sites such as eBay or Amazon.  Here is an eBay search for \"WS2812b led strip\":</p> <p>Search eBay for WS2812b LED strip</p> <p>Note that the term \"WS2812b\" is technically the name of the integrated </p> <p>If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon.  This guide provides sample links to both eBay and Amazon, but be aware that these sites change frequently.</p>"},{"location":"getting-started/parts/#ws-2812b-led-strip","title":"WS-2812B LED Strip","text":"<p>You can purchase the LED strips for around $3.00 per meter if you shop around on eBay.  The above was from seller btflightingcom.  We use the 60 pixels/meter type without waterproofing for our indoor classes.  People who create costumes use waterproof varieties.</p>"},{"location":"getting-started/parts/#ip-waterproofing-ratings","title":"IP Waterproofing Ratings","text":"<p>IP stands for \"Ingress Protection\" or how the strips will hold up in costumes or different outdoor environments.</p> <p>In general, there are three varieties of waterproofing we find when purchasing LED strips.</p> <ol> <li>IP20 - Not Waterproof - least expensive and good for general indoor classroom use when the LED strips can be attached to a plastic strip to avoid bending</li> <li>IP65 - Waterproof (Silicon Coating) - ideal for take-home projects and costumes</li> <li>IP67 - Waterproof (PVC Tube) - perfect for outdoor applications</li> </ol> <p>The IP ratings you mentioned for WS2812B LED strips refer to their level of waterproofing and dust resistance. Each rating is defined as follows:</p>"},{"location":"getting-started/parts/#ip20","title":"IP20:","text":"<p>The first digit (2) indicates the level of protection against solid objects, including body parts like fingers and objects such as tools and wires. A rating of 2 means that the object is protected against solid objects larger than 12.5mm (such as fingers).</p> <p>The second digit (0) indicates the level of protection against liquids. A rating of 0 means there is no protection against liquids.</p> <p>Summary: IP20 means that the LED strip is not waterproof and has minimal protection against solid objects. It's suitable for indoor use where it won't be exposed to water.</p>"},{"location":"getting-started/parts/#ip65","title":"IP65:","text":"<p>The first digit (6) indicates a high level of protection against solid objects, including dust. This means it's completely dust-tight. The second digit (5) refers to protection against water jets. This means the LED strip is protected against low-pressure water jets from any direction.</p> <p>Summary: IP65 means the LED strip is dust-tight and can withstand low-pressure water jets, making it suitable for outdoor use or in environments where it might get wet, like kitchens or bathrooms.</p>"},{"location":"getting-started/parts/#ip67","title":"IP67","text":"<p>The first digit (6) is the same as in IP65, indicating complete protection against dust. The second digit (7) indicates a higher level of water protection. It means the LED strip can be submerged in water up to 1 meter in depth for up to 30 minutes.</p> <p>Summary: IP67 means the LED strip is both dust-tight and can handle temporary immersion in water. This makes it ideal for outdoor applications and environments where the strip might be submerged briefly, such as around pools or in certain landscape lighting scenarios.</p> <p>Note, some of these parts are also called \"NeoPixels\".</p> <p></p> <p>NeoPixels are parts that contain three LEDs and logic to process an incoming data stream.  Each NeoPixel will look at the incoming data and extract the 8-bit values for its own red, green and blue LED brightness.  It then sends the data signal on to the next NeoPixel.</p> <p></p>"},{"location":"getting-started/parts/#soldering","title":"Soldering","text":"<p>Many of the parts you purchase online might require some soldering to make them easy to use.  We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder.  Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school.</p>"},{"location":"getting-started/parts/#headers","title":"Headers","text":"<p>Many of the Pico's don't come with headers.  You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay.</p> <p>Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors</p>"},{"location":"getting-started/parts/#microcontrollers","title":"MicroControllers","text":""},{"location":"getting-started/parts/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>We use the Raspberry Pi Pico (far left) because it only costs about $4.</p> <p></p> <p>It also mounts directly on the breadboard after we add the header pins.</p>"},{"location":"getting-started/parts/#neopixels","title":"NeoPixels","text":""},{"location":"getting-started/parts/#header-pins","title":"Header Pins","text":"<p>If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11.</p> <p>100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip</p>"},{"location":"getting-started/parts/#breadboards","title":"Breadboards","text":"<p>We use 400-tie 1/2 size breadboards.  You can purchase them on E-Bay for around $1.50 each in quantity 10.</p> <p></p>"},{"location":"getting-started/parts/#momentary-push-buttons","title":"Momentary Push Buttons","text":"<p>Tactile Switches</p> <p></p> <p>We use these buttons </p> <p>Part Description: 100PCS B3F-4055 12127.3 Tactile Switch 12x12x7.3mm</p> <p></p> <p>The caps are 140PCS Round Tactile Button Cap Kits 9.585.1mm for 1212*7.3mm Tact Switch on eBay</p> <p></p>"},{"location":"getting-started/parts/#screw-headers","title":"Screw Headers","text":"<p>We attach screw headers to the plexiglass base that we put the kits on.  This allows us to change the LED strip or ring for each project with just a screwdriver.  This is key because many classrooms don't allow soldering irons in the classrooms.</p> <p> </p> <p>We purchase screw headers on eBay</p>"},{"location":"getting-started/parts/#led-strip-3-pin-sm-jst-connectors","title":"LED Strip 3-Pin SM JST Connectors","text":"<p>We purchase our LED strips in 1-meter lengths of 60 pixels per meter.  When they arrive, they have both a male and a female 3-pin SM JST connector on the ends. This allows these LED strips to be connected end-to-end for strips that are longer than 1 meter.</p> <p>LED Strip 3-Pin SM JST Part Listing on eBay</p>"},{"location":"getting-started/parts/#boxes","title":"Boxes","text":"<p>Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends.  We use clear boxes that you can purchase at The Container Store</p> <p>Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084</p> <p>These boxes have a clear detachable lid that shows off the interior wiring of their kits.</p>"},{"location":"getting-started/parts/#micropython-site","title":"MicroPython Site","text":"<p>For more parts, see the CoderDojoTC MicroPython website.</p>"},{"location":"getting-started/updating-firmware/","title":"How to Update Firmware on the Raspberry Pi Pico","text":"<p>Both the Raspberry Pi Foundation and the MicroPython development teams keep improving the software we use in our classrooms. These changes are usually small and don't impact our classrooms. However, occasionally there are \"breaking changes\" that we need to adapt our devices and code examples.</p> <p>When this happens we need to update the firmware on our classroom Raspberry Pi Pico.  This is easy to do.  It takes under five minutes to do your first one and the process can be streamlined for subsequent devices.</p>"},{"location":"getting-started/updating-firmware/#steps","title":"Steps","text":"<p>Here are the key steps:</p> <ol> <li>Download the new firmware from here: https://micropython.org/download/RPI_PICO/</li> <li>Hold down the BOOTSEL button while you turn on the Pico (that is the key step)</li> <li>Drag the new file into the folder that pops up.  It should take under 10 seconds to download.</li> </ol> <p>Let's now review these three steps in detail.</p>"},{"location":"getting-started/updating-firmware/#step-1-downloading-the-new-firmware-image","title":"Step 1: Downloading the new firmware image","text":"<p>The firmware that we use for the Raspberry Pi Pico (not the W) is stored here:</p> <p>https://micropython.org/download/RPI_PICO/</p> <p>When you go to this page, you will see a list of the latest releases.  It will look like this:</p> <p></p> <p>Note that the top line is in red color but has the black label \"(latest)\" next to it.  That is the one we use almost all the time.  We only go back to a prior if there is a bug in the latest release or our code is incompatible with the latest release.</p> <p>To do the download, you need to click on this first line.  The text is in red and is in the first part of the line.  The second part of the line is a link to the release notes.</p> <p>After I click on this link the download should automatically start up. The file is about 640K bytes (under 1 megabyte) and it should finish in under five seconds.</p> <p></p> <p>On most computers, the new file will now appear in your \"Downloads\" folder. You can identify it because it has the extension \"UF2\" for \"USB Flashing Format\". The \"2\" is for the two \"Fs\" and the fact that the extension \"UFF\" was already taken.</p> <p></p>"},{"location":"getting-started/updating-firmware/#sidebar-what-is-the-uf2-format","title":"Sidebar: What is the UF2 format?","text":"<p>The extension \".uf2\" stands for \"USB Flashing Format\". It is used primarily for microcontrollers, like the Raspberry Pi Pico, in the context of firmware updates or software uploads. This format is particularly designed to make it easy to flash a device over USB without needing a special flashing tool or software. The UF2 file contains the firmware that is to be uploaded to the microcontroller. When connected to a computer, the Raspberry Pi Pico can appear as a USB storage device, and the UF2 file can be dragged and dropped onto it to update the firmware or load new software. This simplicity and convenience are significant advantages, especially for educational purposes or for hobbyists who might not have extensive experience with programming microcontrollers.</p>"},{"location":"getting-started/updating-firmware/#step-2-press-the-bootsel-button-during-power-up","title":"Step 2: Press the BOOTSEL Button During Power-Up","text":"<p>Our next step is to locate the BOOTSEL button on the Pico.  It is a small white oval button on the top of the Pico.  Now hear is the tricky part.  You must hold this button down when you boot up the Pico.  This process makes the Pico look like a USB hard drive.  Your PC or MAC will then open it up as a folder on your desktop.</p> <p>I usually hold the BOOTSEL with one hand and then plug the Pico USB cable into a PC or laptop with the other hand.  This can be a bit tricky if the laptop is on a slippery surface.  After you do this a folder called RPI-RP2 should automatically appear on your desktop.</p>"},{"location":"getting-started/updating-firmware/#step-3-drag-the-firmware-to-the-folder","title":"Step 3: Drag the Firmware to the Folder","text":"<p>You are now all set to copy the new firmware to the Raspberry Pi folder. One way to do this is by dragging the new .uf2 file over the  Since the fill is small, this should take under 10 seconds.</p> <p>You can also select the .uf2 file and select the \"copy\" menu.  Then select the new RPI-RP2 folder and do a \"paste\".</p> <p>After the file is copied you will get a \"Disk Not Ejected Properly\" warning like this:  This is normal.  You can just close the warning panel.</p>"},{"location":"getting-started/updating-firmware/#verifying-the-upgrade-worked","title":"Verifying the Upgrade Worked","text":"<p>After this step is done, you can open your Thonny IDE and verify that the firmware matches the version you just uploaded to the Pico.</p> <p>You can do this by pressing the STOP/Restart Backend button and look at the prompt in the Shell window.</p> <p>Example before firmware upgrade:  Note that the version is now v1.20.0</p> <p>Example after firmware upgrade:  Note that the version is now v1.22.1</p>"},{"location":"getting-started/updating-firmware/#side-note-on-boot-select-files","title":"Side Note on Boot Select Files","text":"<p>After you hold the BOOTSEL down and power up you will see the RPI-RP2 folder. If you open the Folder RPI-RP2 you you will see the following.</p> <p></p> <p>This has two very small files.  If you click on the index.htm file your browser will go to the Raspberry Pi documentation website.</p> <p>The other info.text</p> <pre><code>UF2 Bootloader v1.0\nModel: Raspberry Pi RP2\nBoard-ID: RPI-RP2\n</code></pre> <p>This shows you that the Raspberry Pi</p>"},{"location":"getting-started/updating-firmware/#alternative-methods","title":"Alternative Methods","text":"<p>If you have problems finding the BOOTSEL button or holding it down when you plug in the USB cable, you can also use a command line tool to perform the firmware update.</p> <p>You can also use Thonny to perform the update.</p> <p>These methods are covered in the Raspberry Pi Pico Documentation Getting Started Guide.</p>"},{"location":"getting-started/updating-firmware/#neopixel-update","title":"NeoPixel Update","text":"<p>One of the key changes that was done to the firmware in 2021 was the inclusion of the NeoPixel library into the MicroPython firmware.  The key change is that the syntax of how we set pixel values changes from a function call in an external library to directly writing to the NeoPixel array.  The new syntax is:</p> <pre><code>strip[i] = (red, green, blue)\nstrip.write()\n</code></pre> <p>If you have old code that used the strip.set(i, red, green, blue) format you can either change the syntax (strongly recommended) or load the old neopixel library and use it.</p> <p>We don't suggest using the library because it is one more complicated step and makes our examples less portable.  If we use the built-in NeoPixel library our code will be consistent with the other examples on the internet.</p>"},{"location":"getting-started/updating-firmware/#framebuffer-drawing-update","title":"Framebuffer Drawing Update","text":"<p>One other change that happened was when the MicroPython firmware library extended the framebuffer drawing library to include both ellipse and polygon drawing functions. Before this update, each display driver needed to include their own individual functions for drawing shapes beyond the basic rectangular drawing functions.  After this update, all our drawing libraries that used framebuffers could call functions directly in firmware.  This made the functions uniform across all our libraries.</p>"},{"location":"holidays/4th-of-july/","title":"4th of July Hat","text":"<pre><code># moving rainbow\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 30\nRAINBOW_LENGTH = 7\nPERCENT_SMALL_COLOR_WHEEL = round(255/RAINBOW_LENGTH)\nPERCENT_COLOR_WHEEL = round(255/NUMBER_PIXELS)\n\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nBUTTON_PIN_1 = 15\nBUTTON_PIN_2 = 14\n\nbutton_presses = 0 # the count of times the button has been pressed\nlast_time = 0 # the last time we pressed the button\n\nbuiltin_led = machine.Pin(25, Pin.OUT)\n# The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail\n\nbutton1 = machine.Pin(BUTTON_PIN_1, machine.Pin.IN, machine.Pin.PULL_DOWN)\nbutton2 = machine.Pin(BUTTON_PIN_2, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\nmode_list = ['moving rainbow', 'moving red dot', 'moving blue dot', 'moving green dot',\n             'red commet', 'blue commet', 'green commet', 'candle flicker', 'random dots', 'bounce',\n             'running lights', 'rainbow cycle', 'cylon scanner']\nmode_count = 16 # len(mode_list)\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is used to tell\n# which pin is used\ndef button_pressed_handler(pin):\n    global mode, last_time\n    new_time = ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # print(pin)\n        # this is a hack but I can't get the pin ID parameter without vars() or attr()\n        pin_num = int(str(pin)[4:6])\n        # this works as long as one of the buttons is this one\n        if pin_num == BUTTON_PIN_1:\n            mode +=1\n        else:\n            mode -=1\n        # wrap around if we get too high\n        mode = mode % mode_count\n        last_time = new_time\n\n# now we register the handler function when the button is pressed\nbutton1.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\nbutton2.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)    \n\n# erase the entire strip\ndef erase():\n    for i in range(0, NUMBER_PIXELS):\n        strip[i] = (0,0,0)\n        strip.write()\n\ndef move_dot(counter, color, delay):\n    strip[counter] = color\n    strip.write()\n    sleep(delay)\n    strip[counter] = (0,0,0)\n\ndef comet_tail(counter, color, delay):\n    for i in range(0, color_count):\n        # we start to draw at the head of the commet N levels away from the counter\n        target = ((level_count - i - 1) + counter) % NUMBER_PIXELS\n        # number to scale by\n        scale = (levels[i] / 255)\n        strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))\n        # erase the tail\n        if counter &gt; 0:\n            strip[counter-1] = (0,0,0)\n        if counter == NUMBER_PIXELS-1:\n            strip[counter] = (0,0,0)\n        strip.write()\n        sleep(delay)\n\ndef moving_rainbow(counter, delay):\n    for i in range(0, RAINBOW_LENGTH-1):\n        color_index = round(i*PERCENT_SMALL_COLOR_WHEEL)\n        color = wheel(color_index)\n        # print(color_index, color)\n        # start at the end and subtract to go backwards and add the counter for offset\n        index = RAINBOW_LENGTH-1 - i  + counter\n        # print(index)\n        if index &lt; NUMBER_PIXELS:\n            strip[index] = color    \n        strip.write()\n    # erase the tail if we are not at the start\n    if counter &gt; 0:\n        strip[counter-1] = (0,0,0)\n        strip.write()\n    # turn off the last pixel at the top\n    if counter == NUMBER_PIXELS-1:\n        strip[counter] = (0,0,0)\n    sleep(delay)\n\ndef candle(delay):\n     green = 50 + randint(0,155)\n     red = green + randint(0,50)\n     strip[randint(0,NUMBER_PIXELS - 1)] = (red, green, 0)\n     strip.write()\n     sleep(delay)\n\ndef random_color(delay):\n    random_offset = randint(0, NUMBER_PIXELS-1)\n    random_color = randint(0, 255)\n    strip[random_offset] = wheel(random_color)\n    strip.write()\n    sleep(delay)\n\ndef random_red_white_blue(delay):\n    for i in range(0,10):\n        random_offset = randint(0, NUMBER_PIXELS-1)\n        random_color = randint(0, 3)\n        if random_color &lt; 1:\n            strip[random_offset] = red\n        elif random_color &lt; 2:\n            strip[random_offset] = white\n        elif random_color &lt; 3:\n            strip[random_offset] = blue\n        strip.write()\n        sleep(delay)\n\nHALF_LENGTH = round(NUMBER_PIXELS/2)\ndef bounce(counter, color, delay):\n    if counter &lt; HALF_LENGTH:\n        strip[counter] = color\n        strip[NUMBER_PIXELS-1 - counter] = color\n        strip.write()\n        strip[counter] = (0,0,0)\n        strip[NUMBER_PIXELS-1 - counter] = (0,0,0)\n        sleep(delay)\n    else:\n        half_counter = counter - HALF_LENGTH\n        strip[HALF_LENGTH - half_counter] = color\n        strip[HALF_LENGTH + half_counter] = color\n        strip.write()\n        strip[HALF_LENGTH - half_counter] = (0,0,0)\n        strip[HALF_LENGTH + half_counter] = (0,0,0)\n        sleep(delay)\n\ndef running_lights(counter, color, spacing, delay):\n    for i in range(0, NUMBER_PIXELS):\n        if (counter+i) % spacing:\n            strip[i] = (0,0,0)\n        else:\n            strip[i] = color\n    strip.write()\n    sleep(delay)\n\ndef rainbow_cycle(counter, delay):\n    for i in range(0, NUMBER_PIXELS):\n        color_index = round(i*PERCENT_COLOR_WHEEL)\n        color = wheel(color_index)\n        # print(color_index, color)\n        strip[(i + counter) % NUMBER_PIXELS] = color\n        strip.write()\n    sleep(delay)\n\n# 0=fwd, 1=rev\nstate = 0\ndef cylon_scanner(delay):\n    global counter, state\n    if state == 0:\n        #print('going forward', counter)\n        strip[counter] = red_light\n        strip[counter+1] = red_med\n        strip[counter+2] = red\n        strip[counter+3] = red_med\n        strip[counter+4] = red_light\n        # erase the tail\n        if counter &gt; 0: strip[counter-1] = off\n        strip.write()\n        sleep(delay)\n        # reverse direction\n        if counter == NUMBER_PIXELS-5:\n            state = 1\n            counter = 0\n            #print('go to reverse', state)\n            return\n    else:\n        i = NUMBER_PIXELS-counter - 5\n        #print('in reverse c=', counter, 'i=', i)\n        strip[i] = red_light\n        strip[i+1] = red_med\n        strip[i+2] = red\n        strip[i+3] = red_med\n        strip[i+4] = red_light\n        strip.write()\n        sleep(delay)\n        # turn off as we move in reverse\n        if i &lt; NUMBER_PIXELS-2:\n            strip[i+4] = off\n        if i == NUMBER_PIXELS - 6:\n            strip[NUMBER_PIXELS-1] = off\n        if i == 0:\n            state = 0\n            counter = 0\n            #print('switching to forward', counter)\n# Global variables\nmode = 0\ncounter = 0\nlast_mode = 1\ndelay = .05\nwhile True:\n    # print only on change\n    if mode != last_mode:\n        # print('mode=', mode, 'running program', mode_list[mode])\n        last_mode = mode\n    if mode == 0:\n        moving_rainbow(counter, delay)\n    elif mode == 1:\n        move_dot(counter, red, delay)\n    elif mode == 2:\n        move_dot(counter, white, delay)\n    elif mode == 3:\n        move_dot(counter, blue, delay)\n    elif mode == 4:  \n        comet_tail(counter, red, .005)\n    elif mode == 5:  \n        comet_tail(counter, white, .005)\n    elif mode == 6:  \n        comet_tail(counter, blue, .005)\n    elif mode == 8:  \n        random_red_white_blue(.01)\n    elif mode == 9:  \n        bounce(counter, red, .10)\n    elif mode == 10:  \n        bounce(counter, white, .10)\n    elif mode == 11:  \n        bounce(counter, blue, .10)\n    elif mode == 12: \n        running_lights(counter, red, 4, .2)\n    elif mode == 13: \n        running_lights(counter, white, 4, .2)\n    elif mode == 14: \n        running_lights(counter, blue, 4, .2)\n    elif mode == 15: \n        rainbow_cycle(counter, .05)\n    elif mode == 16: \n        cylon_scanner(.05)\n    else:\n        print('mode', mode, 'not configured')\n\n    counter += 1\n    # wrap the counter using modulo\n    if counter == NUMBER_PIXELS:\n        counter = counter % NUMBER_PIXELS\n        mode += 1\n    if mode == 16:\n        mode = 0\n</code></pre>"},{"location":"led-noodles/","title":"LED Noodles","text":"<p>LED Noodles or \"filament\" LEDs are 3-volt flexible LEDs that are perfect for costumes and other wearable items.  They come in multiple colors and typically draw about 100 milliamps.  Our STEM students love to work with them because of their combination of brightness and flexibility.</p> <p>These lesson plans begin with simple static battery circuits with a current limiting resistor.  After that, we proceed to dynamic circuits that are controlled by a Raspberry Pi Pico running MicroPython.</p>"},{"location":"led-noodles/#static-circuits","title":"Static Circuits","text":"<p>Our first section gives you recipes for simple LED Noodle circuits using a variety of battery packs and USB power packs.  The circuits are simple and just are turned on and off or are controlled by a dimmer or photo-sensor.  They are ideal for beginner projects that focus on how the LEDs are used with flexible fabric and clothing.</p> <p>Static Circuits</p>"},{"location":"led-noodles/#led-noodle-dimmer","title":"LED Noodle Dimmer","text":"<p>Our LED Noodles can get very bright in a dark room. Many of our users want to control how bright they are on a costume.  To do this we created a simple LED dimmer circuit using a potentiometer and transistor.</p> <p>LED Noodle Dimmer Circuit</p>"},{"location":"led-noodles/#led-noodle-nightlight","title":"LED Noodle Nightlight","text":"<p>This fun project makes our LED Noodle only turn on when it is dark.  The circuit is perfect for a nightlight. We use a photo-sensor and a transistor to turn on the LED.</p> <p>LED Noodle Nightlight</p>"},{"location":"led-noodles/#calculating-battery-life","title":"Calculating Battery Life","text":"<p>So your LED costume is the hit of your Halloween party. But will your costume work all night?  This lab and MicroSim will help you find out!</p> <p>Calculating Battery Life</p>"},{"location":"led-noodles/#dynamic-circuits","title":"Dynamic Circuits","text":"<p>Once we are familiar with how LED Noodles are controlled, we can take the next step and power them by microcontrollers like the Raspberry Pi Pico and MicroPython.  These projects allow us to not only control the brightness of a single LED Noodle but also allow the LED Noodles to sequently light up in waves.</p> <p>Dynamic Projects</p>"},{"location":"led-noodles/#voltage-current-curve","title":"Voltage Current Curve","text":"<p>For a given voltage across the LED, how can we calculate the amount of current that will be sent through the LED Noodle?  The answer is not as simple as you might expect.</p> <p>Voltage Current Curve</p>"},{"location":"led-noodles/#other-project-ideas","title":"Other Project Ideas","text":"<p>Project Ideas</p>"},{"location":"led-noodles/calculating-battery-life/","title":"Calculating LED Noodle Battery Life","text":"<p>So your LED costume is the hit of your Halloween party. But will your costume work all night?  This lab and the attach MicroSim will help you find out!</p>"},{"location":"led-noodles/calculating-battery-life/#introduction","title":"Introduction","text":"<p>In this lesson, students will learn how to calculate the battery life of their Halloween costumes that use LED Noodles. Understanding battery capacity and power consumption is essential for ensuring that costumes stay illuminated throughout Halloween festivities.</p>"},{"location":"led-noodles/calculating-battery-life/#learning-objectives","title":"Learning Objectives","text":"<p>At the end of this lesson we will be able to </p> <p>By the end of this lesson, students will be able to:</p> <ul> <li>Understand the concept of milliamp hours (mAh) and how it relates to battery capacity.</li> <li>Calculate the total current draw of their LED Noodle costumes.</li> <li>Determine the estimated battery life based on different battery types and configurations.</li> <li>Make informed decisions about battery choices for their costumes.</li> <li>Use and understand a simple webpage to calculate battery life.</li> </ul> <p></p>"},{"location":"led-noodles/calculating-battery-life/#materials-needed","title":"Materials Needed","text":"<ul> <li>LED Noodles (1 to 5 per student)</li> <li>Dimmer knobs</li> <li>Various batteries (2, 3, or 4 AA batteries, 9-volt batteries, USB power packs)</li> <li>Calculators</li> <li>Worksheets for practice problems</li> <li>Whiteboard and markers</li> <li>(optional) Current meter</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#background-knowledge","title":"Background Knowledge","text":"<p>Students should have a basic understanding of:</p> <ul> <li>Electrical current (measured in amperes or milliamperes)</li> <li>Basic arithmetic operations to calculate the total capacity of a set of batteries</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#lesson-steps","title":"Lesson Steps","text":""},{"location":"led-noodles/calculating-battery-life/#step-1-introduction-to-milliamp-hours-mah","title":"Step 1: Introduction to Milliamp Hours (mAh)","text":"<ul> <li>Explain: Milliamp hours (mAh) measure a battery's energy capacity. It indicates how much current a battery can supply over one hour.</li> <li>Example: A battery rated at 2000 mAh can deliver 200 milliamps for ten hours or 1000 milliamps for two hours.</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#step-2-understanding-battery-capacities","title":"Step 2: Understanding Battery Capacities","text":"<ul> <li> <p>Discuss the typical capacities of different batteries:</p> </li> <li> <p>AA Batteries: Approximately 2000--3000 mAh each</p> </li> <li>9-Volt Batteries: Around 500--600 mAh</li> <li>USB Power Packs: Varies widely (e.g., 5000 mAh, 10000 mAh)</li> <li>Note: Using multiple AA batteries in series increases voltage but not capacity. Parallel configurations increase capacity but are not typical for AA batteries in standard holders.</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#step-3-calculating-total-current-draw","title":"Step 3: Calculating Total Current Draw","text":"<ul> <li>Explain how to determine the total current draw:</li> <li>Per LED Noodle: Up to 100 milliamps (mA) at full brightness</li> <li>Dimmer Setting: Adjusts brightness and reduces current draw proportionally</li> <li>Sample Formula:</li> </ul> <p>Total Current Draw (mA) = Number of LED Noodles \u00d7 Current per Noodle (mA) \u00d7 Brightness Factor</p> <p>Brightness Factor: Percentage of maximum brightness (e.g., 50% brightness = 0.5)</p> <p>Example:</p> <ul> <li>3 LED Noodles at 75% brightness:</li> </ul> <p>Total Current Draw = 3 \u00d7 100 mA \u00d7 0.75 = 225 mA</p>"},{"location":"led-noodles/calculating-battery-life/#step-4-calculating-battery-life","title":"Step 4: Calculating Battery Life","text":"<ul> <li>Introduce the formula for battery life:</li> </ul> <p>Battery Life (hours) = Battery Capacity (mAh) \u00f7 Total Current Draw (mA)</p> <ul> <li>Considerations:</li> <li>Real-world battery life may be less due to factors like battery age and efficiency.</li> <li> <p>Battery capacity remains the same in series configurations but voltage increases.</p> </li> <li> <p>Example:</p> </li> <li> <p>Using a USB power pack of 5,000 mAh with a total current draw of 225 mA:</p> </li> </ul> <p>Battery Life = 5000 mAh \u00f7 225 mA \u2248 22.22 hours</p>"},{"location":"led-noodles/calculating-battery-life/#step-5-practice-problems","title":"Step 5: Practice Problems","text":"<ul> <li> <p>Provide scenarios for students to calculate:</p> </li> <li> <p>Scenario: A costume uses 5 LED Noodles at full brightness with a 9-volt battery (600 mAh).</p> </li> <li> <p>Calculate Total Current Draw:</p> </li> </ul> <p>Total Current Draw = 5 \u00d7 100 mA \u00d7 1.0 = 500 mA             ` Calculate Battery Life:</p> <p>Battery Life = 600 mAh \u00f7 500 mA = 1.2 hours             ` 2.  Scenario: A student uses 2 AA batteries (total capacity of one AA battery is 2500 mAh) with 2 LED Noodles at 50% brightness. - Note: Capacity remains 2500 mAh; voltage increases with batteries in series. - Calculate Total Current Draw:</p> <p>Total Current Draw = 2 \u00d7 100 mA \u00d7 0.5 = 100 mA             ` - Calculate Battery Life:</p> <p>Battery Life = 2500 mAh \u00f7 100 mA = 25 hours</p>"},{"location":"led-noodles/calculating-battery-life/#step-6-discuss-real-world-factors","title":"Step 6: Discuss Real-World Factors","text":"<ul> <li>Explain that actual battery life may vary due to:</li> <li>Battery quality and age</li> <li>Ambient temperature</li> <li>Variations in LED efficiency</li> <li>Encourage students to consider these factors in their planning.</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#conclusion","title":"Conclusion","text":"<ul> <li>Recap the importance of calculating battery life.</li> <li>Emphasize making informed choices to ensure costumes remain illuminated.</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#assessment","title":"Assessment","text":"<ul> <li>Worksheet Completion: Collect and review practice problem worksheets.</li> <li>Group Discussion: Share calculations and discuss any differences.</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#additional-resources","title":"Additional Resources","text":"<ul> <li>Battery Life Calculator</li> </ul>"},{"location":"led-noodles/calculating-battery-life/#sample-chatgpt-prompt-for-generating-a-lesson-plan","title":"Sample ChatGPT Prompt for Generating a Lesson Plan","text":"<pre><code>I am working with a class of [9th] grade students that are\nusing LED Noodles that consume up to 100 milliamps when fully bright.\nThey are used in Halloween costumes.\n\nWe use a variety of power sources including 2, 3 or 4, AA batteries,\n9-volt batteries and a variety of USB power packs.\nThe costumes have a dimmer know that allows the students to adjust the brightness of their costumes.  Their costumes have between one and five LED noodles.\n\nPlease generate a complete lesson plan that helps students\nlearn to calculate the battery life of our costumes based on milliamp hours.\n\nReturn the lesson plan in Markdown format with each section\nusing a level 2 header.\n\nAssume at the end of the lesson there is a link to a JavaScript powered battery lifetime calculator.\n</code></pre>"},{"location":"led-noodles/calculating-battery-life/#sample-microsim-prompt","title":"Sample MicroSim Prompt","text":"<pre><code>Create a p5.js sketch that simulates a LED noodle battery life calculator.\nThe title of the sketch is LED Noodle battery Life Calculator\nThe sketch as a series of input controls using a selection list and sliders.\nThe purpose of the calculator is to estimate how long an LED costume will last.\nThe  inputs to the calculator are the following:\n\n1. Battery Type - (Selection List Values of: AA, AAA, 9-volt, USB Battery Pack (small, medium and large) - default AA\n2. Number of batteries (Slider 1, 2, 3 or 4 batteries) - default 2\n3. Number of LED noodle (Slider with values of 1, 2, 3, 4, or 5) - default 2\n4. Current draw for each noodle (Slider with labeled values of (very dim, dim, medium, bright, very bright) with values of 2 milliamps, 5 milliamps, 10 milliamps, 50 milliamps, 100 milliamps)\n\nAs the user change the sliders, continually update the following:\nOutput Line 1: the total milliamp hours of the battery\nOutput Line 2:  the total current draw for the costume\nOutput Line 3: The estimated time for the costume to reach 50% brightness due to battery drain\n</code></pre>"},{"location":"led-noodles/dynamic-projects/","title":"LED Noodle Labs","text":""},{"location":"led-noodles/dynamic-projects/#parts","title":"Parts","text":"<ol> <li>Breadboard</li> <li>Raspberry Pi Pico</li> <li>LED Noodle</li> <li>15 ohm current limiting resistor</li> <li>10K base resistor</li> <li>2N2222 NPN resistor</li> </ol>"},{"location":"led-noodles/dynamic-projects/#circuit","title":"Circuit","text":"<p>LED noodles can use over 100 milliamps. Most digital outputs are rated at only 20 milliamps. So to get enough current, we need to use a transistor as a switch to turn the LED noodle on and off.</p> <p></p> <ol> <li>Connect the output of GPIO 15 to the 10k base resistor</li> <li>Connect the other end of the base resistor to the middle pin of the 2N2222 transistor</li> <li>Connect the emitter to ground</li> <li>Connect the collector to the 15 ohm current limiting resistor</li> <li>Connect the other end of the 15 ohm current limiting resistor to the cathode end (no hole) of the LED noodle</li> <li>Connect the other end of the LED noodle (anode with hole) to the 5 volt rail</li> </ol>"},{"location":"led-noodles/dynamic-projects/#blink","title":"Blink","text":"<pre><code>from machine import Pin, PWM\nfrom time import sleep\n\n# lower left corner of the Pico\nLED_PIN_1 = 15\nled_1 = machine.Pin(LED_PIN_1, machine.Pin.OUT)\ndelay = 1.0 3 # one second on and one second off\n\n# Main loop: Repeat the forever...\nwhile True:\n    print('high')\n    led_1.high() # turn on the LED\n    sleep(delay) # leave it on for 1 second\n\n    print('low')\n    led_1.low()  # Turn off the LED\n    sleep(delay) # leave it off for 1 second\n</code></pre>"},{"location":"led-noodles/dynamic-projects/#fade-in-and-out","title":"Fade In and Out","text":"<pre><code>from machine import Pin, PWM\nfrom time import sleep\n\n# lower left corner of the Pico\nLED_PIN_1 = 15\npwm = PWM(Pin(LED_PIN_1))\n\npwm.freq(1000)\nMAX_BRIGHTNESS = 65025\n\nwhile True:\n    for duty in range(MAX_BRIGHTNESS):\n        pwm.duty_u16(duty)\n        sleep(0.0001)\n    for duty in range(MAX_BRIGHTNESS, 0, -1):\n        pwm.duty_u16(duty)\n        sleep(0.0001)\n</code></pre> <p>Note that the brightness does not change much for the second half of the brightness.   To get a more even change, you can change the <code>MAX_BRIGHTNESS = 32000</code>.</p>"},{"location":"led-noodles/dynamic-projects/#sequential-fade-in-and-out","title":"Sequential Fade In and Out","text":"<p>Now, let's connect five different LED noodles of different colors up and have them turn on in a sequence, one after another.</p> <p>We can just create five copies of the lines that define the LEDs and repeat this pattern over and over.</p> <pre><code>from machine import Pin, PWM\nfrom time import sleep, sleep_ms\n\n# lower left corner of the Pico\nLED_PIN_1 = 11\nLED_PIN_2 = 12\nLED_PIN_3 = 13\nLED_PIN_4 = 14\nLED_PIN_5 = 15\n# led_1 = machine.Pin(LED_PIN_1, machine.Pin.OUT)\npwm_1 = PWM(Pin(LED_PIN_1))\npwm_2 = PWM(Pin(LED_PIN_2))\npwm_3 = PWM(Pin(LED_PIN_3))\npwm_4 = PWM(Pin(LED_PIN_4))\npwm_5 = PWM(Pin(LED_PIN_5))\n\npwm_1.freq(1000)\npwm_2.freq(1000)\npwm_3.freq(1000)\npwm_4.freq(1000)\npwm_5.freq(1000)\n\nMAX_BRIGHTNESS = 32000\nDELAY_MS = 1\nwhile True:\n    # turn up the brightness\n    for duty in range(0, MAX_BRIGHTNESS, 100):\n        pwm_1.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n    # turn down the brightness\n    for duty in range(MAX_BRIGHTNESS, 0, -100):\n        pwm_1.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n\n    for duty in range(0, MAX_BRIGHTNESS, 100):\n        pwm_2.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n    for duty in range(MAX_BRIGHTNESS, 0, -100):\n        pwm_2.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n\n    for duty in range(0, MAX_BRIGHTNESS, 100):\n        pwm_3.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n    for duty in range(MAX_BRIGHTNESS, 0, -100):\n        pwm_3.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n\n    for duty in range(0, MAX_BRIGHTNESS, 100):\n        pwm_4.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n    for duty in range(MAX_BRIGHTNESS, 0, -100):\n        pwm_4.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n\n    for duty in range(0, MAX_BRIGHTNESS, 100):\n        pwm_5.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n    for duty in range(MAX_BRIGHTNESS, 0, -100):\n        pwm_5.duty_u16(duty)\n        sleep_ms(DELAY_MS)\n</code></pre>"},{"location":"led-noodles/dynamic-projects/#heartbeat","title":"Heartbeat","text":"<p>We can add a one second sleep to the off period to simulate the beating of a heart.</p> <pre><code>from machine import Pin, PWM\nfrom time import sleep, sleep_ms\n\n# lower left corner of the Pico\nLED_PIN_1 = 12\npwm = PWM(Pin(LED_PIN_1))\npwm.freq(1000)\nMAX_BRIGHTNESS = 20000\n\nwhile True:\n    for duty in range(0, MAX_BRIGHTNESS, 200):\n        pwm.duty_u16(duty)\n        sleep_ms(2)\n    for duty in range(MAX_BRIGHTNESS, 0, -200):\n        pwm.duty_u16(duty)\n        sleep_ms(2)\n    sleep(1)\n</code></pre>"},{"location":"led-noodles/gamma-correction/","title":"Gamma Correction","text":"<p>Gamma Correction is a way to adjust how bright things look to match how our eyes actually see them. When you change the brightness of something like an LED, the light doesn't always appear to change smoothly. This is because our eyes don't see light in a perfectly straight way.</p> <p>Here's a simple way to think about it:</p> <ul> <li> <p>Without Gamma Correction: If you turn up the brightness by small amounts, the LED might look like it's getting bright too quickly at first and then not much brighter as you keep increasing the brightness. It doesn't feel smooth.</p> </li> <li> <p>With Gamma Correction: We use a special formula to adjust the brightness in a way that matches how your eyes see it. So, when you change the brightness of the LED, it looks like it's increasing evenly from dim to bright.</p> </li> </ul> <p>Imagine trying to turn up the volume on a speaker: without correction, it might feel like the volume jumps too quickly, while with correction, the sound would get louder in a smooth and controlled way.</p> <p>In short, Gamma Correction is like a tool that smooths out the changes in brightness so the LED looks like it's getting brighter in a way that feels natural to your eyes.</p>"},{"location":"led-noodles/gamma-correction/#python-function-to-do-gamma-correction","title":"Python Function to Do Gamma Correction","text":"<pre><code>from machine import Pin, PWM, ADC\nimport time\nimport math\n\n# Setup PWM pin\npwm_pin = PWM(Pin(15))  # PWM pin connected to the base of the 2N2222 (e.g., GP15)\npwm_pin.freq(1000)      # PWM frequency of 1kHz\n\n# Setup photoresistor circuit connected to ADC pin\nadc_pin = ADC(Pin(26))  # Photoresistor connected to ADC pin (e.g., GP26)\n\n# Gamma correction function\ndef gamma_correct(value, gamma):\n    normalized = value / 255  # normalize input to range 0-1\n    corrected = math.pow(normalized, gamma)  # apply gamma correction\n    return int(corrected * 255)  # scale back to range 0-255\n\n# Function to set PWM duty cycle with Gamma Correction\ndef set_led_brightness(brightness, gamma=2.2):\n    corrected_brightness = gamma_correct(brightness, gamma)\n    pwm_pin.duty_u16(int(corrected_brightness * 65535 / 255))  # Set corrected PWM value\n\n# Test the setup by sweeping brightness values\ndef sweep_brightness():\n    for i in range(256):\n        set_led_brightness(i)  # Increase brightness\n        time.sleep(0.01)\n    for i in range(255, -1, -1):\n        set_led_brightness(i)  # Decrease brightness\n        time.sleep(0.01)\n\n# Function to read the photoresistor value\ndef read_brightness():\n    return adc_pin.read_u16()  # Returns a value from 0 to 65535\n\n# Main loop to demonstrate brightness control\ndef main():\n    gamma = 2.2  # Initial gamma value\n    while True:\n        brightness = 128  # Example fixed brightness level (can modify to test)\n        set_led_brightness(brightness, gamma)\n        measured_light = read_brightness()  # Measure the actual brightness using photoresistor\n        print(f\"Measured light: {measured_light}\")  # Display brightness reading\n        time.sleep(1)\n\n# Start the program\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"led-noodles/gamma-correction/#explanation-of-code","title":"Explanation of Code:","text":"<ol> <li> <p>PWM Setup: The PWM signal is configured on a pin (GP15) connected to the base of the 2N2222 transistor through a 10K resistor. The frequency is set to 1kHz.</p> </li> <li> <p>Gamma Correction Function:</p> </li> <li> <p>The function <code>gamma_correct(value, gamma)</code> applies a gamma curve to the brightness value. The value is normalized (0 to 255) and then raised to the power of the gamma correction value.</p> </li> <li>The gamma value of 2.2 is a typical default but can be adjusted based on how you want the LED brightness to behave.</li> </ol>"},{"location":"led-noodles/gamma-correction/#testing-brightness-level","title":"Testing Brightness Level","text":"<p>How do we know our gamma correction function is working and tha the constant value of 2.2 is a good value to use?  We can test this by using a photoresistor to measure the about of light generated by the LED.</p> <ul> <li>We can use the <code>sweep_brightness()</code> function sweeps the brightness values from 0 to 255 (full range), testing the effect of gamma correction on brightness.</li> <li>A photoresistor circuit connected to an ADC pin measures the actual brightness, providing feedback on how the LED is behaving.</li> <li>We can observe the photoresistor readings to adjust the gamma correction for a more visually uniform brightness curve.</li> </ul>"},{"location":"led-noodles/gamma-correction/#tuning-gamma-correction","title":"Tuning Gamma Correction:","text":"<ol> <li> <p>Gamma Value: The <code>gamma</code> parameter can be modified in the <code>set_led_brightness</code> function. Start with a gamma of 2.2, then adjust higher for a steeper curve or lower for a flatter one.</p> </li> <li> <p>Lower gamma (&lt;2.2): Makes the brightness ramp up more quickly at lower levels.</p> </li> <li>Higher gamma (&gt;2.2): Makes the brightness ramp up more slowly, giving more granularity at lower brightness levels.</li> <li> <p>Test Setup:</p> </li> <li> <p>Connect the photoresistor circuit to an analog input on the Raspberry Pi Pico. Ensure that the photoresistor is positioned to detect light from the LED noodle.</p> </li> <li>Monitor the <code>measured_light</code> output in the <code>main()</code> loop and adjust the gamma based on the readings to achieve the desired brightness curve.</li> </ol>"},{"location":"led-noodles/led-noodle-dimmer/","title":"LED Noodle Dimmer","text":"<p>LED noodles can be very bright.  When used in a costume at a party in a dark room, the brightness can been overwhelming! To be attractive, the brightness of the LEDs need to be turned down.</p> <p>In this lesson, we will use a potentiometer to change the brightness of one or more LED noodles.  We will start using a simple potentiometer in series with the LED and then move on to circuits with finer grain of control.</p> <p>Warning</p> <p>Be carful when you are adjusting the resistance of these circuits.  We never want the current limiting resistor to go to zero.  That will burn out the LED noodle.  We suggest ALWAYS having a 15 ohm resistor in series with the LED noodle so you don't accidentally burn it out using a 5 volt power supply.</p>"},{"location":"led-noodles/led-noodle-dimmer/#designing-our-dimmer-circuit","title":"Designing our Dimmer Circuit","text":"<p>To design a dimmer circuit for your LED noodle using a 10\u202fk\u03a9 potentiometer and NPN transistors like the 2N2222, we'll create a simple adjustable current control circuit that utilizes the full range of your potentiometer.</p>"},{"location":"led-noodles/led-noodle-dimmer/#circuit-components","title":"Circuit Components:","text":"<ul> <li>Power Supply: 5\u202fV USB source</li> <li>LED Noodle: Requires 2.39\u202fV (no current) to 2.75\u202fV (max 140\u202fmA)</li> <li>Potentiometer: 10\u202fk\u03a9 linear taper</li> <li>Transistor: NPN transistor (e.g., 2N2222)</li> <li>Resistor\u200b: 10\u202fk\u03a9 resistor to limit base current to the transistor</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#circuit-connections","title":"Circuit Connections","text":"<ol> <li> <p>Potentiometer Setup:</p> <ul> <li>Connect the two outer terminals of the 10\u202fk\u03a9 potentiometer to +5\u202fV and GND.</li> <li>The wiper (middle terminal) provides a variable voltage from 0\u202fV to 5\u202fV as you turn the potentiometer.</li> </ul> </li> <li> <p>Base Connection:</p> <ul> <li>Connect the wiper through a 10\u202fk\u03a9 resistor \u200b to the base of the NPN transistor.  This is the middle pin of the 2N2222 transistor.</li> <li>This resistor limits the base current to protect the transistor.</li> <li> <p>Emitter Connection:</p> </li> <li> <p>Connect the emitter of Q1Q1Q1 directly to GND.</p> </li> <li> <p>Collector Connection:</p> </li> <li> <p>Connect the collector of Q1Q1Q1 to the cathode of the LED noodle.</p> </li> <li>Connect the anode of the LED noodle to +5\u202fV.</li> </ul> </li> </ol>"},{"location":"led-noodles/led-noodle-dimmer/#circuit-description","title":"Circuit Description","text":""},{"location":"led-noodles/led-noodle-dimmer/#variable-voltage-control","title":"Variable Voltage Control","text":"<ul> <li>The potentiometer adjusts the voltage at the base of the transistor from 0\u202fV to approximately 5\u202fV.</li> <li>As the base voltage increases, the transistor allows more collector current, increasing the brightness of the LED noodle.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#current-regulation","title":"Current Regulation","text":"<ul> <li>The 2.7\u202fk\u03a9 resistor RbR_bRb\u200b ensures the base current (I-base)\u200b doesn't exceed safe levels.</li> <li>Maximum base current when the wiper is at 5\u202fV: I-base</li> </ul> <ul> <li>The transistor's current gain (\u03b2 \u2248 100) allows collector current I\u200b up to:</li> </ul> <ul> <li>The value of 160 milliamps exceeds our required 140\u202fmA, providing a full dimming range.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#full-range-potentiometer-use","title":"Full Range Potentiometer Use","text":"<ul> <li>The potentiometer adjusts from minimum brightness (off) at 0\u202fV to maximum brightness at 5\u202fV.</li> <li>This setup utilizes the full mechanical range of the potentiometer for smooth dimming control.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#power-dissipation-check","title":"Power Dissipation Check","text":"<ul> <li>Transistor Power Dissipation:</li> <li>At maximum current (140\u202fmA), the voltage across the transistor VCEV is:</li> </ul> <p>We can now calculate the power dissipation in the 2N222 transistor:</p> <p></p> <ul> <li>The 2N2222 transistor can handle this power, as its maximum rating is around 625\u202fmW.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#final-notes","title":"Final Notes","text":""},{"location":"led-noodles/led-noodle-dimmer/#transistor-selection","title":"Transistor Selection","text":"<ul> <li>Ensure your transistor can handle the maximum collector current (140\u202fmA) and power dissipation.</li> <li>The 2N2222 is suitable, but alternatives like the 2N4401 or any NPN transistor with similar or better ratings can also be used.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#heat-considerations","title":"Heat Considerations","text":"<ul> <li>At higher currents, the transistor may get warm. If necessary, attach a small heat sink to dissipate heat.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#safety-measures","title":"Safety Measures","text":"<ul> <li>Double-check all connections before powering the circuit.</li> <li>Ensure all components are rated appropriately to prevent overheating or damage.</li> </ul>"},{"location":"led-noodles/led-noodle-dimmer/#conclusion","title":"Conclusion","text":"<p>By following this circuit design, we can smoothly control the brightness of our LED noodle using the full range of your 10\u202fk\u03a9 potentiometer, with readily available components and without exceeding the specifications of your components.</p>"},{"location":"led-noodles/led-noodle-nightlight/","title":"LED Noodle Nightlight","text":"<p>We can create a nightlight that only goes on at night by adding a photo-sensor to our LED circuit. https://youtube.com/shorts/LriJtNihyxY?si=2bpKlWYxMg4UexWk</p> <p></p> <p>In this circuit, there is a 22K ohm resistor that connects the base of the 2N2222 transistor to the +5 volt power rail.</p> <p>Note that because there is a voltage drop across the 2N2222 transistor, we can omit the 15 ohm current limiting resistor we need for a 5 volt power supply.</p> <p>Warning</p> <p>Be carful when connected the LED noodle. We never want to directly connect the LED noodle directly to +5 volts and GND. We suggest ALWAYS having a 15 ohm resistor in series with the LED noodle when testing so you don't accidentally burn out the LED noodle using a 5-volt power supply.</p>"},{"location":"led-noodles/led-noodle-nightlight/#light-dependant-resistors","title":"Light Dependant Resistors","text":"<p>The photo-sensor we use is called a light-dependant-resistor or (LDR).  The LDR high resistance when it is dark, but when there is light shining on the sensor the resistance is low. In our circuit, light on the LDR pulls the voltage of the base down to ground and shuts off the flow of current between the collector and the emitter.</p> <p>When it is dark, the resistance of the LDR is high, which causes the 10K bias resistor to pull the base up to 5V.  This lets the current flow between the collector and the emitter.</p> <p>LDR sensors are inexpensive.  You can typically get 30 of them on eBay for under $2.  You can also combine them in parallel to create very sensitive sensors.</p>"},{"location":"led-noodles/led-noodle-nightlight/#measuring-on-and-off-resistance","title":"Measuring On and Off Resistance","text":"<p>To create the right sensitivity of the nightlight, we need to carefully measure the resistance of your LDR under different lighting conditions. This is easy to do with a standard digital multimeter set to measure the resistance of a circuit.</p> <p></p> <p>In the circuit above, I wrapped the bottom part of the LED in black electrical tape and then measured the resistance in two conditions:</p> <ol> <li>When the LDR was uncovered - which gave a resistance across the LDR of about 20K ohms.</li> <li>When the LDR was covered by my finger (which still transmitted some light) - which gave a resistance of about 2K ohms.</li> </ol> <p>I tried various different values of resistors using a 50K potentiometer.</p> <p>The value that gave me the best value for testing in my classroom was a 22K ohm resistor. The value of resistor that you use for the bias resistor might vary depending on how sensitive your LDR is and how bright your room lights are.</p> <p>You can also test the extreme values of the LDR by completely covering the LDR with black electrical tape which should give you a resistance of close to one megohm.</p> <p>You can also shine a bright flashlight directly on the LDR to get a resistance of around 100 ohms. </p>"},{"location":"led-noodles/led-noodle-nightlight/#dividing-the-voltage","title":"Dividing the Voltage","text":"<p>This circuit illustrates the concept of a \"voltage divider\".  A voltage divider uses two resistor in series between the rails of a power supply. When you measure the voltage of the center between the resistors, the voltage is somewhere between the positive voltage and ground.  The exact value is a ratio of the resistors.</p> <p>For example, if you have a 10K on the top and a 20K on the bottom, the value will be 1/3 of the way between the top and the bottom.</p> <p>In the case of the LDR, we can measure the resistance with light and without light and select a pull-up resistor that is about 1/2 the value of the on and off resistances.</p>"},{"location":"led-noodles/led-noodle-nightlight/#project-ideas","title":"Project Ideas","text":"<p>You can cover the LED Noodle with a cutout of a pumpkin for Halloween or make a star or Christmas tree glow at night, but stay off during the day.</p>"},{"location":"led-noodles/led-noodle-nightlight/#references","title":"References","text":"<p>Build Electronics Circuits - This version uses a similar circuit, but it uses a 9-volt battery, a 100K resistor and a BC947 transistor.  However, the principal is the same.</p>"},{"location":"led-noodles/project-ideas/","title":"LED Noodle Project Ideas","text":"<p>Here are some fun, creative project ideas for kids using LED Noodles. LED Noodles only cost a few dollars each, so projects can include many LED Noodles each with their own switches.</p>"},{"location":"led-noodles/project-ideas/#wearable-light-bracelet-or-headband","title":"Wearable Light Bracelet or Headband","text":"<p>Using a flexible LED Noodle, kids can create glowing bracelets or headbands.  Secure the noodle with Velcro or fabric, and add a small battery pack hidden in a pocket or behind a design. An LED can also be a great safety device when walking at night.</p> <p>Learning Opportunity: A great introduction to wearable electronics and circuits.</p>"},{"location":"led-noodles/project-ideas/#led-nightlight","title":"LED Nightlight","text":"<p>Add a photo-sensor to only turn on the LED Noodle when there is no light.  You can do this with a single transistor.</p>"},{"location":"led-noodles/project-ideas/#light-up-picture-frame","title":"Light-Up Picture Frame","text":"<p>Kids can decorate a plain picture frame with LED Noodles.  They can tape or glue the LED Noodles around the frame to create a glowing effect around their favorite photo or drawing.</p> <p>Learning Opportunity: Teaches basic circuitry and adds a creative element with personal artwork or photos.</p>"},{"location":"led-noodles/project-ideas/#led-noodle-shoelaces","title":"LED Noodle Shoelaces","text":"<p>Kids can lace LED Noodles into their shoes and light up their steps.  The flexible noodle can be woven like regular shoelaces,  with a small battery pack attached to the side of the shoe.</p> <p>Learning Opportunity: This project combines creativity with practical hands-on experience, introducing them to how circuits work with motion.</p>"},{"location":"led-noodles/project-ideas/#glowing-stuffed-animal","title":"Glowing Stuffed Animal","text":"<p>Take an old or DIY stuffed animal and weave LED Noodles into its body to create a glowing plush friend. The battery pack can be stored inside the stuffed animal with a simple on/off switch.</p> <p>Learning Opportunity: Encourages both crafting and basic electronics by integrating LEDs into soft materials.</p>"},{"location":"led-noodles/project-ideas/#illuminated-diy-house-or-maze","title":"Illuminated DIY House or Maze","text":"<p>Build a cardboard house, maze, or puzzle and use LED Noodles to light the paths. The noodle can be placed around the maze borders or inside the maze to create a glowing effect.</p> <p>Learning Opportunity: Enhances problem-solving skills while teaching kids about how electricity flows through circuits.</p>"},{"location":"led-noodles/project-ideas/#glow-in-the-dark-mask-or-costume","title":"Glow-in-the-Dark Mask or Costume","text":"<p>Kids can create a mask or costume for dress-up or Halloween using LED Noodles to light up different parts of their design. The noodles can outline the eyes, mouth, or patterns on the costume.</p> <p>Learning Opportunity: Teaches kids about low-power lighting and how to make functional yet artistic wearables.</p>"},{"location":"led-noodles/project-ideas/#bed-light-or-canopy","title":"Bed Light or Canopy","text":"<p>Make a canopy over a bed or play area and use the LED Noodles to create a starry sky effect.  The noodles can be strung across the fabric or attached to a wireframe to mimic stars or constellations.</p> <p>Learning Opportunity: Provides a fun way to introduce astronomy while experimenting with creative lighting setups.</p>"},{"location":"led-noodles/project-ideas/#colorful-paper-lanterns","title":"Colorful Paper Lanterns","text":"<p>Kids can make their own paper lanterns and illuminate them from inside with LED Noodles. By using colored paper or tissue, they can create unique glowing designs.</p> <p>Learning Opportunity: A simple and fun way to learn about how light interacts with colors and transparency.</p>"},{"location":"led-noodles/project-ideas/#glowing-bike-decoration","title":"Glowing Bike Decoration","text":"<p>Add LED Noodles to the spokes of a bicycle or wrap them around the frame for a glowing ride. The noodles are flexible enough to twist around the bike's shape, making the bike visible at night.</p> <p>Learning Opportunity: Encourages outdoor activities while learning about powering small electronics safely.</p>"},{"location":"led-noodles/project-ideas/#interactive-light-up-book-cover","title":"Interactive Light-Up Book Cover","text":"<p>Description: Use LED Noodles to make the cover of a notebook or book glow. Kids can design a creative cover using cardboard or felt and weave the LED Noodles into the design.</p> <p>Learning Opportunity: Combines art with electronics to make personalized school supplies.</p> <p>These projects not only engage creativity but also provide hands-on learning with basic electronics, enhancing their understanding of circuitry, electricity, and DIY design.</p>"},{"location":"led-noodles/static-circuits/","title":"Static Circuits","text":""},{"location":"led-noodles/static-circuits/#led-noodle-polarity","title":"LED Noodle Polarity","text":""},{"location":"led-noodles/static-circuits/#two-aa-or-aaa-battery-power","title":"Two AA or AAA Battery Power","text":"<p>This simple circuit has just two AA or AA batteries.  Each has a voltage of 1.5 volts.  When they are configured in series, the voltages of each battery is added together to give a voltage of 3 volts. This is exactly the recommended voltage for the LED Noodle!</p> <p></p> <p>Connect the terminals directly to the battery pack. Make sure that the positive polarity is connected to the end with the hole.  We used a soldering iron and standard tin-lead solder with a low melting point and that did not impact any of our LED noodles.</p>"},{"location":"led-noodles/static-circuits/#three-aa-or-aaa-battery-power","title":"Three AA or AAA Battery Power","text":"<p>If we need a little longer battery power, we can upgrade from two batteries to three.  This gives us a combined voltage of 4.5 volts (3 x 1.5 volts).</p> <p>To limit the current, we will need a a 15 ohm current-limiting resistor in series with a battery pack.</p> <p></p> <p>It is possible to use slightly different values of the current-limiting resistor.  A 10-ohm resistor will give a brighter light, but will drain the batteries faster.</p> <p>LED Noodle Calculator</p>"},{"location":"led-noodles/static-circuits/#9-volt-battery","title":"9-Volt Battery","text":"<p>Although they are not commonly used in our labs, in a pinch you can also use a 9-volt battery to light up the LED noodles.</p> <p></p> <p>Use a 100 ohm resistor in series with the battery.</p> <p></p> <p>9-volt batteries are easy to connect but they don't offer the best value compared to AA batteries.</p>"},{"location":"led-noodles/static-circuits/#usb-battery-packs","title":"USB Battery Packs","text":"<p>One great option is to use a rechargeable USB battery pack. These supply 5 volts and because they are rechargeable, they can be used many times over and over.</p> <p></p> <p>In the diagram above, we used a 20 ohm resistor in series with the LED noodle to limit the current to about 62 milliamps.  This is more than bright enough for most applications.  A 50 ohm resistor is also a good option and the battery will last considerably longer, but the LED will not be as bright.</p>"},{"location":"led-noodles/voltage-current-curve/","title":"Voltage Current Curve","text":""},{"location":"led-noodles/voltage-current-curve/#collecting-data","title":"Collecting Data","text":"<p>Using a DC power supply, we can measure the exact voltage across the LED filament as well as the current.  Here is a sample table of the current drawn for each voltage from 2.39 to 2.8 volts.</p> Voltage(v) Current(mA) 2.39 0 2.52 1 2.53 2 2.54 5 2.55 7 2.56 10 2.58 22 2.60 28 2.61 34 2.65 52 2.68 71 2.70 88 2.72 100 2.74 113 2.6 124 2.8 140"},{"location":"led-noodles/voltage-current-curve/#plotting-these-values","title":"Plotting These Values","text":"<p>Here is a plot of these values:</p> <p></p>"},{"location":"led-noodles/voltage-current-curve/#creating-an-interactive-microsimulation","title":"Creating an Interactive MicroSimulation","text":"<p>Link to Interactive Simulation</p> <p>Note that this simulation was mostly created by ChatGPT o1-preview.  I had to adjust a few lines to make the plot a little more presentable.</p> <p>Here are the key aspects of this MicroSimulation:</p> <ul> <li>Plot Area: The plot occupies a central area within the canvas, with margins for labels and tick marks.</li> <li>Background: The canvas background is set to \"aliceblue\" for a pleasant visual effect.</li> <li>Gridlines: Light gray gridlines divide the plot area into a 10x10 grid for better readability.</li> <li>Axes: Both axes are drawn with thicker lines and include tick marks and labels.</li> <li>Data Curve: The voltage vs. current curve is drawn by interpolating between the provided data points.</li> <li>Data Points: Original data points are highlighted as red circles for emphasis.</li> <li>Interactive Dot: A blue dot moves along the curve as you adjust the voltage slider, indicating the current at that voltage.</li> </ul> <p>Here is the ChatGPT prompt that I used:</p> <pre><code>Create a p5.js sketch on a 600x600 canvas that shows the current\nwhen an input voltage changes, the current also changes in an LED circuit.\n\nMake the background of the canvas be \"aliceblue\". \nMake a single-line plot with voltage on the horizontal axis and current on the vertical axis.\nMake the title of the plot be \"LED Noodle Voltage vs. Current\".\nLabel the vertical axis \"Current\" and the horizontal axis \"Voltage\".\n\nMake the gridlines be light gray.\nAdd axis labels for both the current and the voltage.\nAdd a slider at the bottom of the canvas that allows the user to change the voltage from 2.35 up to 2.78 in steps of 0.01 with the default value of 2.55.\nWhen the user adjusts the slider, move a blue dot along the curve.\n\nUse the following data to draw the curve.  Draw the data points with a red circle.\n\n|Voltage(v)|Current(mA)|\n|------:|------:|\n|2.39|0|\n|2.52|1|\n|2.53|2|\n|2.54|5|\n|2.55|7|\n|2.56|10|\n|2.58|22|\n|2.60|28|\n|2.61|34|\n|2.65|52|\n|2.68|71|\n|2.70|88|\n|2.72|100|\n|2.74|113|\n|2.6|124|\n|2.8|140|\n</code></pre>"},{"location":"led-noodles/voltage-current-curve/#estimating-the-current-with-a-function","title":"Estimating the Current with a Function","text":"<p>Although our data gives us some precise data, there are always variables in our measurements.  However, we can see that the behavior of the current falls under two regions.  Below about 2.5 volts the current is essential zero.  Above 2.5 volts the curve is mostly a line with a little curve in it that shows an slight exponential growth.</p> <p>We can come up with a formula to approximate this using the following function:</p> <pre><code>function calculateCurrent(v) {\n  if (v &lt;= 2.5) {\n    return 0;\n  } else {\n    let A = 0.3296; // in mA\n    let B = 24; // per Volt\n    let linearCurrent = A * 300 * (v - 2.5);\n    let exponentialCurrent = 0.4 * Math.exp(B * (v - 2.5));\n    let current = linearCurrent + exponentialCurrent;\n    if (current &gt; 140) current = 140; // Limit to maximum data point\n    return current;\n  }\n}\n</code></pre> <p>You can explore more about this \"curve fitting process\" by looking at my chat with ChatGPT o1.preview.</p>"},{"location":"lessons/","title":"Moving Rainbow Lessons","text":""},{"location":"lessons/#simple-individual-patterns","title":"Simple Individual Patterns","text":"<ol> <li>Blink - blink the first pixel red on and off</li> <li>Fade In and Out - Make the first pixel fade in and out</li> <li>Heartbeat - Change the first red pixel to beat like a heartbeat</li> <li>Red, Green and Blue - Draw red, green and blue colors in different places</li> <li>Color Wheel - draw all the colors of the rainbow</li> <li>A Better Dimmer - making our dimmer more uniform</li> <li>Moving Pixel - move a pixel up and down the LED strip</li> <li>Color Wipe - change the color one pixel at a time</li> <li>Bounce - dots crash in the center of the strip</li> <li>Comet - make a block of color move with a dimming tail</li> <li>Moving Rainbow - move a block of colors </li> <li>Rainbow Cycle - cycle every pixel through all the colors of the rainbow</li> <li>Larson Scanner - famous Cylon eye and KITT car scanning pattern</li> <li>Random Colors - draw random colors at each pixel</li> <li>Twinkle - random pixels twinkle on for a brief second</li> <li>Ripple - simulated drops in a pond in 1-D</li> <li>Random Bounce - random points bounce around</li> <li>Candle - simulated candle flickers with randomness</li> <li>Theater Chase - classic running light patterns popular in signs</li> <li>Moving Bands - moving bands of color</li> </ol>"},{"location":"lessons/#rotating-patterns","title":"Rotating Patterns","text":"<ol> <li>Modes - assign a mode to each pattern</li> <li>Button Modes - use buttons to change a mode</li> </ol>"},{"location":"lessons/01-blink/","title":"Blink","text":"<p>Here is one of simplest moving rainbow programs.  It is our version of \"Hello World!. </p> <p>Our first program will just blink the first pixel on and off every 1/2 second.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    # turn first red pixel on for 1/2 second\n    strip[0] = (255,0,0)\n    strip.write()\n    sleep(.5)\n\n    # turn off for 1/2 second\n    strip[0] = (0,0,0)\n    strip.write()\n    sleep(.5)\n</code></pre>"},{"location":"lessons/01-blink/#exercises","title":"Exercises","text":""},{"location":"lessons/01-blink/#change-the-color-lab","title":"Change the Color Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: <code>strip[0] = (0,255,0)</code></li> </ol> <p>What happens?</p>"},{"location":"lessons/01-blink/#change-the-position-lab","title":"Change the Position Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: strip[1] = (255,0,0)</li> </ol> <p>What happens?</p>"},{"location":"lessons/01-blink/#change-the-sleep-time","title":"Change the Sleep Time","text":"<p>What happens if you change the sleep time?</p> <p>from: <code>sleep(.5)</code> to: <code>sleep(.1)</code></p> <p>What is the smallest time you can use and still see flashing?  Hint: Try values like <code>.05</code>, or <code>.005</code></p>"},{"location":"lessons/01-blink/#rgb-lab","title":"RGB Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: <pre><code>strip[0] = (255,0,0)\nstrip[1] = (0,255,0)\nstrip[2] = (0,0,255)\n</code></pre> and change the <pre><code>    strip[0] = (0,0,0)\n    strip[1] = (0,0,0)\n    strip[2] = (0,0,0)\n</code></pre></li> </ol> <p>What happened?</p>"},{"location":"lessons/01-blink/#why-do-we-need-stripwrite","title":"Why Do We Need Strip.Write?","text":"<p>Try to remove one of the line that does strip.write().  What happens?  Why do you think we need this line?</p>"},{"location":"lessons/01-blink/#led-strip-state","title":"LED Strip State","text":"<p>What happens if you stop the program when the LED strip LEDs are on? </p>"},{"location":"lessons/01-blink/#on-your-own","title":"On Your Own","text":"<p>What if you extended the lab to more positions and colors?</p>"},{"location":"lessons/02-fade-in-and-out/","title":"Fade In and Out Lab","text":"<p>What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer?  To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps.</p> <pre><code>from neopixel import NeoPixel\nfrom time import sleep\n\nNUMBER_PIXELS = 1\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\n# the time between each of the 255 brightness steps\ndelay = .01\n\nwhile True:\n    # slowly get brighter\n    for i in range(0, 255):\n        strip[0] = (i,0,0) # red=255, green and blue are 0\n        strip.write() # send the data from RAM down the wire\n        sleep(delay)\n    # slowly get dimmer\n    for i in range(255, 0, -1):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(delay)\n</code></pre>"},{"location":"lessons/03-heartbeat/","title":"Heartbeat Lab","text":"<p>What if you were building a robot and you wanted to flash the LED to look like a human heartbeat?  Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this:</p> <p></p> <p>Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below.</p> <p>The following code emulates this heart beat pattern:</p> <pre><code>from neopixel import NeoPixel\nfrom time import sleep\n\n# Most people have a heart rate of around 60-70 beats per minute\n# If we add a once second delay between \"beats\" you can make and LED\n# look like a beating heart.\n\nNUMBER_PIXELS = 1\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\nramp_delay = .001\nbeat_delay = 1\nskip_interval = 10\n\nwhile True:\n    # ramp brightness up using the ramp_delay\n    for i in range(0, 255, skip_interval):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(ramp_delay)\n    # ramp brightness down using the same delay\n    for i in range(255, 0, -skip_interval):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(ramp_delay)\n    strip[0] = (0,0,0)\n    strip.write()\n    sleep(beat_delay)\n</code></pre>"},{"location":"lessons/04-red-green-blue/","title":"Red, Green and Blue","text":"<p>In this lesson, we will draw three different colors at three different locations on the LED strip.  We will then repeat this pattern down the strip.</p> <p>Our first task is to draw the red, green and blue in the first three pixels of the LED strip.</p> <p>Our main code will be the following</p> <pre><code># make the fist location red\nstrip[0] = (255,0,0)\n# make the second location green\nstrip[1] = (0,255,0)\n# make the third location blue\nstrip[2] = (0,0,255)\n# update the strip\nstrip.write()\n</code></pre>"},{"location":"lessons/04-red-green-blue/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# make the fist location red\nstrip[0] = (255,0,0)\n# make the second location green\nstrip[1] = (0,255,0)\n# make the third location blue\nstrip[2] = (0,0,255)\n# update the strip\nstrip.write()\n</code></pre>"},{"location":"lessons/04-red-green-blue/#repeating-the-pattern","title":"Repeating the Pattern","text":"<p>Now, let's repeat this pattern over the entire strip.  We can do this by wrapping the three lines in a for loop like this:</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# count 0 to the end skipping every 3\nfor i in range(0, NUMBER_PIXELS-1, 3):\n    strip[i] = (255,0,0)\n    # make the second location green\n    strip[i+1] = (0,255,0)\n    # make the third location blue\n    strip[i+2] = (0,0,255)\n    # update the strip\nstrip.write()\n</code></pre> <p>Note here that the range function has a third parameter that tells us how many to skip in each iteration of the loop.  Since we have three colors, we can skip every three values of i.  I will get values of 0, 3, 6, 9, 12... etc.</p>"},{"location":"lessons/04-red-green-blue/#excercises","title":"Excercises","text":""},{"location":"lessons/05-color-wheel/","title":"Color Wheel Lab","text":"<p>What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow?  What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value.  This is known as the <code>`wheel</code> function:</p> <pre><code>def wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n</code></pre> <p>If you follow the code, you will see that the colors range from red through green and to blue and back to red:</p> <pre><code>wheel(1) = (255, 0, 0) # red\nwheel(85) = (0,255, 0) # green\nwheel(170) = (0, 0, 255) # blue\nwheel(255) = (255, 0, 0) # red\n</code></pre>"},{"location":"lessons/05-color-wheel/#full-program","title":"Full Program","text":"<p>This program will continu</p> <pre><code>import machine\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 1\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ncounter = 0\nwhile True:\n    strip[0] = wheel(counter)\n    strip.write()\n    sleep(.01)\n    counter += 1\n    # reset the counter\n    if counter == 255:\n        counter = 0\n</code></pre>"},{"location":"lessons/06-linear-dimmer/","title":"Linear Dimmer","text":"<p>We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness.</p> <p></p> <p></p> <p>https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html</p>"},{"location":"lessons/06-linear-dimmer/#gamma-correction-table","title":"Gamma Correction Table","text":"<pre><code>gamma8= [\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,\n    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,\n   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,\n   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,\n   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,\n   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,\n   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,\n   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,\n   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,\n  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,\n  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,\n  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,\n  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255]\n</code></pre> <pre><code>## Gamma Correction Function\n# input is an integer from 0 to 255\ndef gamma8(input):\n    return gamma8[input]\n</code></pre>"},{"location":"lessons/07-motion/","title":"Motion","text":"<p>Turning individual pixels on and off is pretty easy.  But the results can be pretty boring after a while.  But don't worry, we can now create a program that is a lot more fun!</p> <p>This program uses the Python <code>for</code> loop.  It uses a counter, called an index, to turn on successive pixels in the strip.  For each pixel it turn it on, delays for a short period of time, and then turns it off.  It then moves on to the next pixel until each pixel is the strip has been turned on for short period.</p>"},{"location":"lessons/07-motion/#move-a-red-pixel","title":"Move a Red Pixel","text":"<p>The following program illustrates this process.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# Create a variable to store the delay \ndelay = .03\nwhile True:\n    for i in range(0, NUMBER_PIXELS - 1):\n        # turn index red pixel on for a short delay\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n\n        # turn off\n        strip[i] = (0,0,0)\n</code></pre> <p>You will note that this program is similar to the blink lab with a few key differences:</p> <ol> <li>The code that turns the pixel on and off is inside the for loop.</li> <li>There is no delay or write after we turn it off.  You could add these back in, but they are not really needed.</li> </ol> <p>Note that the delary time in this program is stored in the <code>delay</code> variable and it is a pretty short delay.  The shorter the delay, the faster the pixel will appear to move.</p>"},{"location":"lessons/07-motion/#experiments","title":"Experiments","text":""},{"location":"lessons/07-motion/#change-the-delay","title":"Change the Delay","text":"<p>Try to change the <code>delay</code> variable to different values.  Note how slow the pixel moves if you make the delay a full second.  This is pretty boring.</p> <ol> <li>Change the delay to be .01.  This is 1/100th of a second.</li> <li>What is the fastest you can make the pixel move?</li> <li>What happens if you make the delay less than <code>.001</code>.  Can you still notice the change in the speed?  Many people can't tell the difference because the time to do the <code>strip.write()</code> function is much longer than the delay.</li> </ol>"},{"location":"lessons/07-motion/#down-and-back","title":"Down and Back","text":"<p>Next, lets try to make the pixel appear to move down the LED strip and then back up.  We call this the \"Down and Back\" pattern.  To do this we just need to duplicate the for loop, but change the range of the index.  Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step:</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# Create a varuabke to store the delay \ndelay = .01\nwhile True:\n    # move down\n    for i in range(0, NUMBER_PIXELS - 1):\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n        strip[i] = (0,0,0)\n\n    # move back\n    for i in range(NUMBER_PIXELS - 1, 0, -1):\n        # turn index red pixel on for and delay\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n        strip[i] = (0,0,0)\n</code></pre>"},{"location":"lessons/07-motion/#advanced-lab-timeing-the-write","title":"Advanced Lab: Timeing the Write","text":"<p>You can measure the time it takes do perform the <code>strip.write()</code> by recording the number of \"ticks\" before and after the write.  See the function <code>time.ticks_us()</code> for details.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, ticks_us\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nstart = ticks_us()\nstrip.write()\nprint(ticks_us() - start)\n</code></pre> <p>On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds.  The shorter the LED strip, the shorter the delay.  Longer LED strips will have a correspondingly longer delay.</p>"},{"location":"lessons/07-motion/#have-some-fun","title":"Have Some Fun!","text":"<ol> <li>Try to change the color of the pixel.</li> <li>Try to change the direction of motion from the last to the beginning pixel.</li> <li>Try making the </li> </ol>"},{"location":"lessons/07-random/","title":"Using Random Numbers","text":"<p>One fun way to spice up our LED strips is to randomly light up a different pixel with a random color.  Here is how we do this.</p> <p>First, We need to import the library that generate random numbers:</p> <pre><code>from urandom import randint\n</code></pre> <p>Next, we need to generate a random number within a fixed range:</p> <pre><code>    random_red_brightness = randint(0, 256)\n</code></pre> <p>Let's create a program that will briefly light up an random pixel with a random color.  To do this we first generate a random location on the LED strip, then we get a random value for the red, green and blue brightness:</p> <pre><code>location = randint(0, NUMBER_PIXELS-1)\n    red = randint(0, 256)\n    green = randint(0, 256)\n    blue = randint(0, 256)\n</code></pre> <p>Here is the full program.</p> <pre><code># 07-random color at a random location\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(Pin(config.NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    location = randint(0, NUMBER_PIXELS-1)\n    red = randint(0, 256)\n    green = randint(0, 256)\n    blue = randint(0, 256)\n    strip[location] = (red, green, blue)\n    strip.write()\n    sleep(.5)\n    strip[location] = (0, 0, 0)\n</code></pre>"},{"location":"lessons/08-color-wipe/","title":"Color Wipe","text":"<p>This lesson shows you how to change the color of the entire LED strip pixel by pixel.  There will be two delays that we can control:</p> <ol> <li>the delay between each pixel update - this is usually about 1/20th of a second</li> <li>the delay between colors - this is usually about 1 to 2 seconds</li> </ol>"},{"location":"lessons/08-color-wipe/#a-simple-color-wipe-function","title":"A Simple Color Wipe Function","text":"<p>To write this program, we will create a simple Python function that will cycle through all the colors in a list.  Our color list will look like this:</p> <pre><code>red = (255, 0, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\n...etc...\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet, white)\n</code></pre> <p>Now with this list</p> <pre><code>def color_wipe(delay, color_delay):\n    for color in colors:\n        for i in range(0, NUMBER_PIXELS):\n            strip[i] = color\n            strip.write()\n            # the delay between each pixel draw\n            sleep(delay)\n        # how long to pause between color changes\n        sleep(color_delay)\n</code></pre> <pre><code>from time import sleep\n\n# most people have a heart rate of around 60-70 beats per minute\n# If you add a once second deplay between \"beats\" you can make and LED\n# look like a beating heart.\n\nNUMBER_PIXELS = 60\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet, white)\n\ndef color_wipe(delay, color_delay):\n    for color in colors:\n        for i in range(0, NUMBER_PIXELS):\n            strip[i] = color\n            strip.write()\n            sleep(delay)\n        # how long to pause between color changes\n        sleep(color_delay)\n\nwhile True:\n    color_wipe(.05, 1)\n</code></pre>"},{"location":"lessons/08-moving-bands/","title":"Moving Bands of Color","text":"<p>In this lesson, we will create a program that will move a set of bands of color down the LED strip.  To do this we will create a function called <code>draw_band(start, end, color)</code> that will fill a range of pixels with a given color.</p> <pre><code>def draw_band(start, end, color, delay):\n    # draw the band from start to end\n    for i in range(start, end):\n        strip[i % NUMBER_PIXELS] = color\n</code></pre> <p>This works, but we also have the problem that the last pixel does not get erased</p> <pre><code>def draw_band(start, end, color, erase_tail, delay):\n    # draw the band from start to end\n    for i in range(start, end):\n        strip[i % NUMBER_PIXELS] = color\n    # erase the last pixel on the erase tail band\n    if erase_tail and start &gt; 0:\n        strip[(start-1) % NUMBER_PIXELS] = (0,0,0)\n    strip.write()\n    sleep(delay)\n</code></pre> <p>We can then draw three \"bands\" of color like this:</p> <pre><code>draw_band(0, 9, 'red')\ndraw_band(10, 19, 'green')\ndraw_band(20, 29, 'blue')\n</code></pre> <p>We can make this group of bands appear to move by adding a offset to the start like this:</p> <pre><code>for i in range(0, NUMBER_PIXELS)\n    draw_band(i, i+9, 'red')\n    draw_band(i+10, i+19, 'green')\n    draw_band(i+20, i+29, 'blue')\n</code></pre> <p>This will work fine until the value of i plus the offset exceeds the length of the LED strip.  To get around this, we should never write to location i by itself.  We should always divide i by the strip lenght and write to the remainder, what is call the modulo.  We just have to change one line in the draw_band function:</p> <pre><code>def draw_band(start, end, color):\n    for i in range(start, end):\n        strip[i%NUMBER_PIXELS] = color\n    strip.write()\n</code></pre>"},{"location":"lessons/08-rainbow/","title":"Rainbow","text":"<pre><code>wheel(current_color)\n</code></pre>"},{"location":"lessons/08-rainbow/#09-rainbowpy","title":"09-rainbow.py","text":"<p>from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint</p>"},{"location":"lessons/08-rainbow/#get-the-configuration-information","title":"get the configuration information","text":"<p>import config</p> <p>np = config.NUMBER_PIXELS strip = NeoPixel(Pin(config.NEOPIXEL_PIN), np)</p>"},{"location":"lessons/08-rainbow/#we-have-each-pixel-step-through-the-color-wheel","title":"we have each pixel step through the color wheel","text":"<p>color_wheel_step = int(256 / np)</p> <p>def wheel(pos):     # Input a value 0 to 255 to get a color value.     # The colors are a transition r - g - b - back to r.     if pos &lt; 0 or pos &gt; 255:         return (0, 0, 0)     if pos &lt; 85:         return (255 - pos * 3, pos * 3, 0)     if pos &lt; 170:         pos -= 85         return (0, 255 - pos * 3, pos * 3)     pos -= 170     return (pos * 3, 0, 255 - pos * 3)</p> <p>current_color = 0 print('Drawing rainbow in', np, 'steps with step size of: ', color_wheel_step) for i in range(0,np):     strip[i] = wheel(current_color)     current_color = current_color + color_wheel_step     print(i, current_color, wheel(current_color))     strip.write()     sleep(.03)</p>"},{"location":"lessons/09-comet-tail/","title":"Comet Tail","text":"<p>In this lesson we will make a pattern of light like a comet tail.  The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet.</p>"},{"location":"lessons/09-comet-tail/#the-draw-comet-tail-function","title":"The Draw Comet Tail Function","text":"<p>Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet.  In general, each pixel will be half as bright and the prior pixel.</p> <p>The \"levels\" of brightness can be stored in a list or calculated.  Our list will look like this:</p> <pre><code># brightness levels starting with max and going to 1\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\n</code></pre> <p>Our function will have three parameters:</p> <ol> <li>The offset from pixel 0</li> <li>The color to draw the pixel as a tuple of three integers</li> <li>The delay between the draws which will control the speed that the comet appears to move down the strip</li> </ol> <p>Here is an example of this function:</p> <pre><code># offset should be incremented by one for motion\ndef draw_comet_tail(offset, color, delay):\n    % make sure we are within the range of the LED strip\n    offset = offset % NUMBER_PIXELS\n    for i in range(0, color_count):\n        target = ((level_count - i - 1) + offset) % NUMBER_PIXELS\n        # number to scale by\n        scale = (levels[i] / 255)\n        # set the target and scale and round to the interger value\n        strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))      \n        if offset &gt; 0:\n            strip[offset-1] = (0,0,0)\n        if offset == NUMBER_PIXELS-1:\n            strip[offset] = (0,0,0)\n        strip.write()\n        sleep(delay)\n</code></pre> <p>The most complex line is this one:</p> <pre><code>strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))\n</code></pre> <p>This line sets the RGB values of the target.  It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet.  After it does the multiplication, it must use the <code>int()</code> function to round the value to the nearest integer.</p>"},{"location":"lessons/09-comet-tail/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, indigo, violet, cyan, white)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\n# offset should be incremented by one for motion\ndef draw_comet_tail(offset, color, delay):\n    offset = offset % NUMBER_PIXELS\n    for i in range(0, color_count):\n        target = ((level_count - i - 1) + offset) % NUMBER_PIXELS\n        # number to scale by\n        scale = (levels[i] / 255)\n        strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))      \n        if offset &gt; 0:\n            strip[offset-1] = (0,0,0)\n        if offset == NUMBER_PIXELS-1:\n            strip[offset] = (0,0,0)\n        strip.write()\n        sleep(delay)\n\n\ndef clear():\n    for i in range(0, NUMBER_PIXELS):\n        strip[i] = (0,0,0)\n    strip.write()\n\n# setup\ncounter = 0\nclear()\n\n# main loop\nwhile True:\n    for color_index in range(0, color_count):\n        for i in range(0, NUMBER_PIXELS):\n            draw_comet_tail(counter, colors[color_index], .005)\n            counter += 1\n            print(counter)\n</code></pre>"},{"location":"lessons/10-moving-rainbow/","title":"Moving Rainbow","text":"<p>In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip.  This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip.</p> <p>We will begin with drawing a static hand-built list of colors on our strip.  We call this doing it \"the hard way\".  After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab.</p>"},{"location":"lessons/10-moving-rainbow/#the-classic-rainbow","title":"The Classic Rainbow","text":"<p>Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet.  We can lookup the red, green and blue values of these colors on Wikipedia.</p> Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 <p>We can then put the colors into a Python data structure called a list:</p> <pre><code># Color RGB values as tuples\nred = (255, 0, 0)\norange = (255, 165, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (238, 130, 238)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n</code></pre> <p>We can then draw these colors in each of the first seven pixels like this:</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nindex = 0\nfor color in colors:\n    strip[index] = colors[index]\n    index += 1\nstrip.write()\n</code></pre> <p>Here is the important new line:</p> <pre><code>strip[index] = colors[index]\n</code></pre> <p>It says, for the current index, set the strip value to the three values in the colors list.</p> <p>We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nfor i in range(0, NUMBER_PIXELS - num_colors + 1):\n    index = 0\n    # draw the rainbow\n    for color in colors:\n        strip[index + i] = colors[index]\n        index += 1\n    strip.write()\n    sleep(.05)\n    # erase the current pixel\n    strip[i] = (0,0,0)\n</code></pre> <p>There are a few tricky adjustments we had to make:</p> <ol> <li>We added the index counter to the strip index so that we would start drawing at a different point each time.</li> <li>We had to not go to the end of the LED strip.  We had to stop <code>num_colors + 1</code> before the end of the strip.</li> <li>We had to erase the current pixel after we drew the colors.</li> </ol>"},{"location":"lessons/10-moving-rainbow/#repeating-the-moving-rainbow","title":"Repeating the Moving Rainbow","text":"<p>Finally, we can wrap this entire section in a <code>while True</code> loop that will keep running the pattern over and over.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nwhile True:\n    for i in range(0, NUMBER_PIXELS - num_colors + 1):\n        index = 0\n        # draw the rainbow\n        for color in colors:\n            strip[index + i] = colors[index]\n            index += 1\n        strip.write()\n        sleep(.05)\n        # erase the current pixel\n        strip[i] = (0,0,0)\n        # erase the last draw\n        if i == NUMBER_PIXELS - num_colors:\n            strip[i+1] = (0,0,0)\n            strip[i+2] = (0,0,0)\n            strip[i+3] = (0,0,0)\n            strip[i+4] = (0,0,0)\n            strip[i+5] = (0,0,0)\n            strip[i+6] = (0,0,0)\n            strip.write()\n</code></pre> <p>Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop.</p>"},{"location":"lessons/10-moving-rainbow/#improving-on-the-moving-rainbow","title":"Improving on the Moving Rainbow","text":"<p>This program is simple to read, but there are several ways we could improve it.</p> <p>One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip.  This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd.</p> <p>For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip.  We can achieve this by using the modulo function.  It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip.</p> <p>What if we wanted our rainbow to be a different number of pixels?  It would be ideal of we could just write a function that would draw the right pixels at the right place.  Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?</p>"},{"location":"lessons/11-rainbow-cycle/","title":"Rainbow Cycle","text":"<p>In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow.</p>"},{"location":"lessons/11-rainbow-cycle/#the-rainbow-cycle-function","title":"The Rainbow Cycle Function","text":"<p>We create a function called <code>rainbow_cycle()</code> that has three parameters.  The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over.</p> <pre><code>def rainbow_cycle(wait, speed, skip):\n    global NUMBER_PIXELS, strip\n    # get a color - speed will skip intermediate colors for faster cycles\n    for j in range(0, 255, speed):\n        for i in range(0, NUMBER_PIXELS, skip):\n            rc_index = (i * 256 // NUMBER_PIXELS) + j\n            # print(rc_index)\n            strip[i] = wheel(rc_index &amp; 255)\n        strip.write()\n    sleep(wait)\n</code></pre> <p>Next, we place a <code>while True()</code> loop at end and call the function repeatedly.  </p>"},{"location":"lessons/11-rainbow-cycle/#power-considerations","title":"Power Considerations","text":"<p>This program has the ability to drive every single pixel on the strip.  This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply.</p> <p>To get around this you can up the <code>skip</code> parameter to only turn on every 2nd, 3rd or 4th pixel.</p> <p>The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts.</p>"},{"location":"lessons/11-rainbow-cycle/#full-program","title":"Full Program","text":"<p>Here is the full program you can run.  Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip.</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ndef rainbow_cycle(wait, speed, skip):\n    global NUMBER_PIXELS, strip\n    # get a color - speed will skip intermediate colors for faster cycles\n    for j in range(0, 255, speed):\n        for i in range(0, NUMBER_PIXELS, skip):\n            rc_index = (i * 256 // NUMBER_PIXELS) + j\n            # print(rc_index)\n            strip[i] = wheel(rc_index &amp; 255)\n        strip.write()\n    sleep(wait)\n\n# s[eed is an integer from 1 to 30\nspeed = 2\n# skip = 1 is every pixel, 2 is every other pixel etc.\n# the hither skip the lower the overall power\nskip = 3\nwhile True:\n    rainbow_cycle(.01, speed, skip)\n</code></pre>"},{"location":"lessons/15-random/","title":"Random Drawing","text":"<p>In this lesson we will introduce the ability to draw random colors at random pixels.  This allows us to create more natural patterns such as the flicking light of a candle.</p>"},{"location":"lessons/15-random/#the-random-functions","title":"The Random Functions","text":"<p>We need a function that will generate a random integer between a range of values. This is called the <code>randint()</code> function and it takes either one or two parameters.  In our case, we can just pass in the minimum and maximum values:</p> <pre><code>randint(0, 256)\n</code></pre> <p>You can read more about MicroPython random functions here</p> <p>To use the random function we first need to import the function from the library:</p> <pre><code>from urandom import randint\n</code></pre> <p>Here is a sample loop that sets each pixel to a random color using the wheel() function:</p> <pre><code>for i in range(0, NUMBER_PIXELS):\n    random_color = randint(0, 256)\n    strip[i] = wheel(random_color)\n    strip.write()\n    sleep(.1)\n</code></pre>"},{"location":"lessons/15-random/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ndef clear():\n    for i in range(0, NUMBER_PIXELS):\n        strip[i] = (0,0,0)\n    strip.write()\n\n# setup\ncounter = 0\nclear()\n\n# main loop\nwhile True:\n    for i in range(0, NUMBER_PIXELS):\n        random_color = randint(0, 256)\n        strip[i] = wheel(random_color)\n        strip.write()\n        sleep(.1)\n</code></pre>"},{"location":"lessons/15-random/#exercises","title":"Exercises","text":"<ol> <li>Instead of updating a single pixel in consecutive sequences, can you also use the <code>randint()</code> function to update a random pixel?</li> <li>What if you have a small fixed list of colors to pick from.  How can you use <code>randint()</code> to pick a color from this list?</li> </ol>"},{"location":"lessons/16-candle/","title":"Candle Flicker","text":"<p>In this lesson we will try to simulate the behavior of a flickering candle using the <code>randint()</code> function.  To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary.  This will give the impression of a candle flame with a flicker.</p> <p>A pure yellow color has both the red and green values on and the blue value off:</p> <pre><code>yellow = (255, 255, 0)\norange = (255, 150, 0)\n</code></pre> <p>Our goal is to generate variations in both color and brightness.  We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50.</p>"},{"location":"lessons/16-candle/#sample-candle-function","title":"Sample Candle Function","text":"<p>Our function will draw the new value on a random location on the LED strip.  It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second.</p> <pre><code>def candle(delay):\n    for i in range(0, NUMBER_PIXELS):\n         green = 50 + randint(0,155)\n         red = green + randint(25,50)\n         strip[randint(0,NUMBER_PIXELS - 1)] = (red, green, 0)\n         strip.write()\n         sleep(delay)\n</code></pre>"},{"location":"lessons/16-candle/#full-demonstration-program","title":"Full Demonstration Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n# https://docs.micropython.org/en/latest/library/random.html\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef candle(delay):\n    for i in range(0, NUMBER_PIXELS):\n         green = 50 + randint(0,155)\n         red = green + randint(25,50)\n         strip[randint(0,NUMBER_PIXELS - 1)] = (red, green, 0)\n         strip.write()\n         sleep(delay)\n\ncounter = 0\nwhile True:\n   candle(.01)\n   # wrap\n   counter = counter % (NUMBER_PIXELS-1)\n   counter += 1\n</code></pre>"},{"location":"lessons/17-theater-chase/","title":"Theater Chase","text":"<p>Theater Chase is a classic pattern that was popularized in marquee signs above movie theaters.  It consists of a row of lights that were usually switched on and off so it would appear that the lights were moving or being chased around the edge of the signs.</p>"},{"location":"lessons/17-theater-chase/#sample-theater-chase-function","title":"Sample Theater Chase Function","text":"<p>To create the illusion of pixels moving along a strip, we need to have three nested loops:</p> <ol> <li>The inner \"i\" loop just moves from 0 to the number of pixels in steps of 3 (or a similarly small number).  It turns every 3rd pixel on, waits and then turns it off</li> <li>The middle \"q\" loop just offsets the starting point of the inner loop moving from values of 0, 1 and 2.  The index in the inner loop is <code>i+q</code>.</li> <li>The outer-most \"j\" loop just indicates how many times the pattern should be repeated</li> </ol> <p>Here is a sample of the <code>theater_chase</code> function that has four parameters:</p> <ol> <li>the LED strip</li> <li>the color</li> <li>the delay (about 50 milliseconds)</li> <li>the number of times the pattern should be repeated (iterations)</li> </ol> <pre><code>def theater_chase(strip, color, wait_ms=50, iterations=10):\n    for j in range(iterations):\n        for q in range(3):\n            # turn every third pixel on\n            for i in range(0, strip.numPixels(), 3):\n                strip[i+q] = color\n            strip.write()\n            # keep the pixels on for a bit like 1/20th of a second\n            sleep_ms(wait_ms)\n            # turn every third pixel off\n            for i in range(0, strip.numPixels(), 3):\n                strip.setPixelColor(i+q, 0)\n</code></pre> <p>If you want to lower the power of the LED strip, you can change the skip number in the inner loop from 3 to 4, 5 or 6 etc.</p>"},{"location":"lessons/17-theater-chase/#full-program","title":"Full Program","text":"<p>This program will run a theater chase for the seven colors of the rainbow and then repeat.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\ndef theater_chase(strip, color, wait_ms=50, iterations=10):\n    for j in range(iterations):\n        for q in range(3):\n            for i in range(0, strip.numPixels(), 3):\n                strip[i+q] = color\n            strip.write()\n            sleep_ms(wait_ms)\n            for i in range(0, strip.numPixels(), 3):\n                strip.setPixelColor(i+q, 0)\n\nwhile True:\n    # iterate through all the colors\n    for c in range(0, num_colors):\n        theater_chase(strip, colors[c], wait_ms=50, iterations=50)\n</code></pre>"},{"location":"lessons/17-theater-chase/#exercises","title":"Exercises","text":"<ol> <li>Add the skip number as an additional parameter to the function</li> <li>Add another parameter that reversed the direction of the movement</li> <li>Create a function that randomly changes the direction every few seconds</li> </ol>"},{"location":"lessons/18-ripple/","title":"Ripple Patterns","text":"<pre><code># moving rainbow\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef ripple(size, color, delay):\n    # start at a random location within size of the ends\n    start = randint(size, NUMBER_PIXELS - size)\n    for i in range(0, size):\n        strip[start+i] = color\n        strip[start-i] = color\n        strip.write()\n        sleep(delay)\n        strip[start+i] = (0,0,0)\n        strip[start-i] = (0,0,0)\n\ndelay = 0.2\nwhile True:\n    ripple(10, red, delay)\n    ripple(10, green, delay)\n    ripple(10, blue, delay)\n</code></pre>"},{"location":"lessons/18-ripple/#exercises","title":"Exercises","text":"<ol> <li>Make the color random</li> <li>Make the size of the ripple random</li> <li>Add randomness to the delay</li> <li>Use the wheel function to pick a random color</li> <li>Make the pixel intensity get lower as the ripple expands</li> </ol>"},{"location":"lessons/18-twinkle/","title":"Twinkle","text":"<p>A twinkle is a light whose brightness varies repeatedly between bright and faint.</p>"},{"location":"lessons/18-twinkle/#sample-twinkle-function","title":"Sample Twinkle Function","text":"<p>This </p> <pre><code>def twinkle(delay):\n    random_index = randint(0, NUMBER_PIXELS);\n    # turn on\n    strip[random_index] = (255,255,255) \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n</code></pre>"},{"location":"lessons/18-twinkle/#full-program","title":"Full Program","text":"<pre><code>from neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef twinkle(delay):\n    random_index = randint(0, NUMBER_PIXELS-1);\n    # turn on\n    strip[random_index] = (255,255,255) \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n\nwhile True:\n    twinkle(.1)\n    sleep(1)\n</code></pre>"},{"location":"lessons/18-twinkle/#exercises","title":"Exercises","text":"<ol> <li>Add a parameter to the <code>twinkle()</code> function to allow the caller to specify the color.</li> <li>Make the brightness of the twinkle function a random value</li> <li>Make the brightness of a twinkle ramp up and down</li> </ol>"},{"location":"lessons/18-twinkle/#twinkle-random-color","title":"Twinkle Random Color","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef twinkle(delay, color):\n    random_index = randint(0, NUMBER_PIXELS-1);\n    # turn on\n    strip[random_index] = color \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n\nwhile True:\n    twinkle(.1, colors[randint(0, color_count-1)])\n    sleep(1)\n</code></pre>"},{"location":"lessons/19-larson-scanner/","title":"Larson Scanner","text":"<p>The Larson Scanner is a light pattern special effect named after Glen A. Larson.  Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience.  See Knight Rider for the backstory.</p>"},{"location":"lessons/19-larson-scanner/#description","title":"Description","text":"<p>A set of usually red pixels moves back and forth over the LED strip.  The pixels are brighter in the center and are dimmer at the edges of the set.  You can see an example of this in the Larson Scanner Pumpkin Kit</p>"},{"location":"lessons/19-larson-scanner/#color-rgb-values","title":"Color RGB values","text":"<p>We will need a set of predefined colors for various brightness of red:</p> <pre><code>red = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0,0,0)\n</code></pre> <p>Note that the color levels are not linear.  You can adjust these and add more intermediate levels for wider patterns.</p>"},{"location":"lessons/19-larson-scanner/#full-source-code","title":"Full Source Code","text":"<pre><code># Larson Scanner - five pixels\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0,0,0)\n\ndelay = .05\nwhile True:\n    # forward loop\n    for i in range(2, NUMBER_PIXELS-2):\n        strip[i-2] = red_light\n        strip[i-1] = red_med\n        strip[i] = red\n        strip[i+1] = red_med\n        strip[i+2] = red_light\n        # erase the trailing pixel\n        if i &gt; 0:\n            strip[i-3] = off\n        strip.write()\n        sleep(delay)\n    # backward loop\n    for i in range(NUMBER_PIXELS-4, 1, -1):\n        # erase the trailing pixel\n        if i &lt; NUMBER_PIXELS-2:\n            strip[i+3] = off\n        strip[i-2] = red_light\n        strip[i-1] = red_med\n        strip[i] = red\n        strip[i+1] = red_med\n        strip[i+2] = red_light\n        strip.write()\n        sleep(delay)\n</code></pre>"},{"location":"lessons/19-larson-scanner/#exercises","title":"Exercises","text":"<ol> <li>Turn the code into a function with delay as a patter</li> <li>Add a color parameter</li> <li>Add a parameter for the width of the pattern</li> </ol>"},{"location":"lessons/20-clock/","title":"Clock","text":"<p>Can you turn your LED strip into a clock?</p> <p>You can use binary encoding to display the numbers in a clock.  To do this we will need a function to display a digit as a binary pattern.</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, localtime\n# get the configuration information\nimport config\n\nnp = config.NUMBER_PIXELS\nstrip = NeoPixel(Pin(config.NEOPIXEL_PIN), np)\n\nsec_bits = [0,0,0,0,0,0]\nmin_bits = [0,0,0,0,0,0]\nhr_bits = [0,0,0,0,0,0]\n\ndef decimal_to_binary(n, a):\n    global sec_bits\n    for i in range(0,6):\n        if n % 2:\n            a[i] = 1\n        else:\n            a[i] = 0\n        ## n halfed\n        n //= 2\n\ndef display_binary(binary, index, color):\n    for i in range(0, 6):\n        # print(i, ' ', end='')\n        if binary[i] == 1:\n            strip[index+i] = color\n        else:\n            strip[index+i] = (0,0,0)\n    strip.write()\n\n# light mark and write\ndef display_mark(loc):\n    strip[loc] = (5,5,5)\n    strip.write()\n\n# update from the first time\n# sec\ndisplay_mark(0)\ndisplay_mark(7)\n\n# min\ndisplay_mark(9)\ndisplay_mark(16)\n\n# min\ndisplay_mark(19)\ndisplay_mark(26)\n\nnow = localtime()\nhour = now[3]\n# use AM/PM 12 hour time\nif hour &gt; 12:\n    hour = hour - 12\nminute = now[4]\n\n# this is not working\ndecimal_to_binary(minute, min_bits)\nprint('initial min:', minute, min_bits)\ndisplay_binary(min_bits, 10, (0,10,0))\n\ndecimal_to_binary(hour, hr_bits)\nprint('initial hour:', hour, hr_bits)\ndisplay_binary(hr_bits, 20, (0,0,10))\n\nwhile True:\n    now = localtime()\n    hour = now[3]\n    # use AM/PM 12 hour time\n    if hour &gt; 12:\n        hour = hour - 12\n    minute = now[4]\n    sec = now[5]\n    print(hour, ':', minute, ' ', sec, sep='')\n    strip.write()\n    decimal_to_binary(sec, sec_bits)\n    print('sec:', sec, sec_bits)\n    display_binary(sec_bits, 1, (10,0,0))\n    if sec == 60:\n        minute = minute + 1\n        sec = 0\n        decimal_to_binary(minute, min_bits)\n        print('min:', minute, min_bits)\n        display_binary(min_bits, 10, (0,10,0))\n        if minute == 60:\n            decimal_to_binary(hour, hr_bits)\n            print('hour:', hour, hr_bits)\n            display_binary(hr_bits, 20, (0,0,10))\n            hour = hour + 1\n            minute = 0\n            if hour == 24:\n                hour = 0\n    sleep(1)\n</code></pre>"},{"location":"lessons/40-how-neopixels-work/","title":"How NeoPixels Work","text":"<p>NeoPixels, such as the WS2812B, are a type of addressable LED commonly used in various lighting projects. Here's an explanation of how they function:</p>"},{"location":"lessons/40-how-neopixels-work/#integrated-control-circuit","title":"Integrated Control Circuit","text":"<p>Each NeoPixel contains a control circuit and an RGB LED. This design makes each LED independently addressable within a strip.</p>"},{"location":"lessons/40-how-neopixels-work/#data-transmission","title":"Data Transmission","text":"<p>NeoPixels are controlled by a digital data signal sent from a microcontroller. This signal is a sequence of binary data.</p>"},{"location":"lessons/40-how-neopixels-work/#signal-processing","title":"Signal Processing","text":"<p>The data signal is sent through a single data line to the strip. Each LED reads its part of the data (usually 24 bits: 8 bits each for Red, Green, and Blue) and uses this information to set its color.</p>"},{"location":"lessons/40-how-neopixels-work/#color-control","title":"Color Control","text":"<p>The color of each LED is determined by the 24 bits of data it receives. These bits represent the intensity levels for each of the red, green, and blue components of the LED. The combination of these intensities produces the final color.</p>"},{"location":"lessons/40-how-neopixels-work/#data-propagation","title":"Data Propagation","text":"<p>After an LED reads its data, it removes (or 'strips') this data from the stream and passes the remaining data to the next LED. The next LED then reads its respective data, and this process continues down the strip.</p>"},{"location":"lessons/40-how-neopixels-work/#sequential-addressing","title":"Sequential Addressing","text":"<p>The first LED in the strip reads the first set of data, the second LED reads the next set, and so on. This sequential processing allows for individual control of each LED in the strip.</p>"},{"location":"lessons/40-how-neopixels-work/#refresh-rate","title":"Refresh Rate","text":"<p>The entire process of data reading and color setting happens very quickly, allowing dynamic effects like color changes to appear smooth.</p>"},{"location":"lessons/40-how-neopixels-work/#electrical-connection","title":"Electrical Connection","text":"<p>Only three connections are required for a NeoPixel strip: power (5V), ground, and data input. This simplicity makes them popular for various lighting projects.</p>"},{"location":"lessons/40-how-neopixels-work/#conclusion","title":"Conclusion","text":"<p>NeoPixels offer a combination of simplicity in wiring and complexity in control, allowing for a wide range of creative lighting applications.</p> <p>This document provides an overview of the basic operation of NeoPixels without delving into the specific technicalities of signal timing and electrical characteristics.</p>"}]}