{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MicroPython Moving Rainbow documentation! Learning to program using LED strips version 2 ''' Note! We are no longer accepting pull request for Arduino C code. Due to the fact that we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python. About Moving Rainbow Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build an entire costume with 100s of LEDs for under $20 Getting Started Addressable LED Strips Addressable LED strips are easy to connect to your project since they only need three wires (Ground, +5V and data). LED strip can be purchased on sites like ebay.com for under $5/meter of 60 RGB LEDs. References CoderDoj CoderDojo Twin Cities CodeSavvy Raspberry Pi Pico The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor. Breadboards In our projects we use 1/2 sized breadboard with 400 tie points. Mode Buttons A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode. Programming the LED strip Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Moving Rainbow Home"},{"location":"#welcome-to-the-micropython-moving-rainbow-documentation","text":"Learning to program using LED strips version 2 ''' Note! We are no longer accepting pull request for Arduino C code. Due to the fact that we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python.","title":"Welcome to the MicroPython Moving Rainbow documentation!"},{"location":"#about-moving-rainbow","text":"Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build an entire costume with 100s of LEDs for under $20","title":"About Moving Rainbow"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#addressable-led-strips","text":"Addressable LED strips are easy to connect to your project since they only need three wires (Ground, +5V and data). LED strip can be purchased on sites like ebay.com for under $5/meter of 60 RGB LEDs.","title":"Addressable LED Strips"},{"location":"#references","text":"CoderDoj CoderDojo Twin Cities CodeSavvy","title":"References"},{"location":"#raspberry-pi-pico","text":"The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor.","title":"Raspberry Pi Pico"},{"location":"#breadboards","text":"In our projects we use 1/2 sized breadboard with 400 tie points.","title":"Breadboards"},{"location":"#mode-buttons","text":"A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode.","title":"Mode Buttons"},{"location":"#programming-the-led-strip","text":"Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Programming the LED strip"},{"location":"getting-started/desktop-setup/","text":"Desktop Setup In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons. About Thonny Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi. Step 1: Install Thonny The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software. Thonny Versions These labs have all been tested on Thonny Version 4.0.4 . Step 2: Configure the MicroPython Firmware After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware. Manually Downloading the Firmware There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware Step 3: Configure Interpreter Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected. Thonny Firmware List After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#desktop-setup","text":"In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#about-thonny","text":"Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.","title":"About Thonny"},{"location":"getting-started/desktop-setup/#step-1-install-thonny","text":"The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software.","title":"Step 1: Install Thonny"},{"location":"getting-started/desktop-setup/#thonny-versions","text":"These labs have all been tested on Thonny Version 4.0.4 .","title":"Thonny Versions"},{"location":"getting-started/desktop-setup/#step-2-configure-the-micropython-firmware","text":"After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.","title":"Step 2: Configure the MicroPython Firmware"},{"location":"getting-started/desktop-setup/#manually-downloading-the-firmware","text":"There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware","title":"Manually Downloading the Firmware"},{"location":"getting-started/desktop-setup/#step-3-configure-interpreter","text":"Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected.","title":"Step 3: Configure Interpreter"},{"location":"getting-started/desktop-setup/#thonny-firmware-list","text":"After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Thonny Firmware List"},{"location":"getting-started/kits/","text":"Moving Rainbow Kits These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10 Standard Parts Our standard kit contains the following parts: A Raspberry Pi Pico ($4) or \"W\" ($6) with header pins soldered in place A 1/2-size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires Optional Parts USB Connectors Most of our classrooms will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector. Batteries and Battery Packs If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern) LED Strip and Rings There are hundreds of variations of WS2812B LED strips and fairy lights. We usually purchase them in 1-meter strips with 60 pixels per meter. Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes. EBay Search for SW2812B LED Fairy Lights","title":"Standard Kits"},{"location":"getting-started/kits/#moving-rainbow-kits","text":"These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10","title":"Moving Rainbow Kits"},{"location":"getting-started/kits/#standard-parts","text":"Our standard kit contains the following parts: A Raspberry Pi Pico ($4) or \"W\" ($6) with header pins soldered in place A 1/2-size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires","title":"Standard Parts"},{"location":"getting-started/kits/#optional-parts","text":"","title":"Optional Parts"},{"location":"getting-started/kits/#usb-connectors","text":"Most of our classrooms will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector.","title":"USB Connectors"},{"location":"getting-started/kits/#batteries-and-battery-packs","text":"If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern)","title":"Batteries and Battery Packs"},{"location":"getting-started/kits/#led-strip-and-rings","text":"There are hundreds of variations of WS2812B LED strips and fairy lights. We usually purchase them in 1-meter strips with 60 pixels per meter. Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes. EBay Search for SW2812B","title":"LED Strip and Rings"},{"location":"getting-started/kits/#led-fairy-lights","text":"","title":"LED Fairy Lights"},{"location":"getting-started/parts/","text":"Purchasing Your Own Parts In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guide is for mentors, parents and students that would like to build their own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on online sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these sites change frequently. Soldering Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school. Headers Many of the Pico's don't come with headers. You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay. Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors MicroControllers Raspberry Pi Pico We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins. NeoPixels Header Pins If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip NeoPixel Rings Raspberry Pi Pico Breadboards Momentary Push Buttons Boxes Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits. MicroPython Site For more parts, see the MicroPython site here:","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#purchasing-your-own-parts","text":"In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guide is for mentors, parents and students that would like to build their own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on online sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these sites change frequently.","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#soldering","text":"Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school.","title":"Soldering"},{"location":"getting-started/parts/#headers","text":"Many of the Pico's don't come with headers. You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay. Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors","title":"Headers"},{"location":"getting-started/parts/#microcontrollers","text":"","title":"MicroControllers"},{"location":"getting-started/parts/#raspberry-pi-pico","text":"We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins.","title":"Raspberry Pi Pico"},{"location":"getting-started/parts/#neopixels","text":"","title":"NeoPixels"},{"location":"getting-started/parts/#header-pins","text":"If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip","title":"Header Pins"},{"location":"getting-started/parts/#neopixel-rings","text":"","title":"NeoPixel Rings"},{"location":"getting-started/parts/#raspberry-pi-pico_1","text":"","title":"Raspberry Pi Pico"},{"location":"getting-started/parts/#breadboards","text":"","title":"Breadboards"},{"location":"getting-started/parts/#momentary-push-buttons","text":"","title":"Momentary Push Buttons"},{"location":"getting-started/parts/#boxes","text":"Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits.","title":"Boxes"},{"location":"getting-started/parts/#micropython-site","text":"For more parts, see the MicroPython site here:","title":"MicroPython Site"},{"location":"lessons/","text":"Moving Rainbow Lessons Blink - blink the first pixel red on and off Fade In and Out - Make the first pixel fade in and out Heartbeat - Change the first red pixel to beat like a heartbeat Red, Green and Blue - Draw red, green and blue colors Color Wheel - draw all the colors of the rainbow A Better Dimmer - making our dimmer more uniform Moving Pixel - move a pixel up and down the LED strip Color Wipe - change the color one pixel at a time Comet - make a block of color move with a dimming tail Moving Rainbow - move a block of colors Rainbow Cycle - cycle every pixel through all the colors of the rainbow","title":"List of Lessons"},{"location":"lessons/#moving-rainbow-lessons","text":"Blink - blink the first pixel red on and off Fade In and Out - Make the first pixel fade in and out Heartbeat - Change the first red pixel to beat like a heartbeat Red, Green and Blue - Draw red, green and blue colors Color Wheel - draw all the colors of the rainbow A Better Dimmer - making our dimmer more uniform Moving Pixel - move a pixel up and down the LED strip Color Wipe - change the color one pixel at a time Comet - make a block of color move with a dimming tail Moving Rainbow - move a block of colors Rainbow Cycle - cycle every pixel through all the colors of the rainbow","title":"Moving Rainbow Lessons"},{"location":"lessons/01-blink/","text":"Blink Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 ) Exercises Change the Color Lab Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens? Change the Position Lab Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens? Change the Sleep Time What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005 RGB Lab Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened? Why Do We Need Strip.Write? Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line? LED Strip State What happens if you stop the program when the LED strip LEDs are on? On Your Own What if you extended the lab to more positions and colors?","title":"Blink"},{"location":"lessons/01-blink/#blink","text":"Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 )","title":"Blink"},{"location":"lessons/01-blink/#exercises","text":"","title":"Exercises"},{"location":"lessons/01-blink/#change-the-color-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens?","title":"Change the Color Lab"},{"location":"lessons/01-blink/#change-the-position-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens?","title":"Change the Position Lab"},{"location":"lessons/01-blink/#change-the-sleep-time","text":"What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005","title":"Change the Sleep Time"},{"location":"lessons/01-blink/#rgb-lab","text":"Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened?","title":"RGB Lab"},{"location":"lessons/01-blink/#why-do-we-need-stripwrite","text":"Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line?","title":"Why Do We Need Strip.Write?"},{"location":"lessons/01-blink/#led-strip-state","text":"What happens if you stop the program when the LED strip LEDs are on?","title":"LED Strip State"},{"location":"lessons/01-blink/#on-your-own","text":"What if you extended the lab to more positions and colors?","title":"On Your Own"},{"location":"lessons/02-fade-in-and-out/","text":"Fade In and Out Lab What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out"},{"location":"lessons/02-fade-in-and-out/#fade-in-and-out-lab","text":"What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out Lab"},{"location":"lessons/03-heartbeat/","text":"Heartbeat Lab What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat"},{"location":"lessons/03-heartbeat/#heartbeat-lab","text":"What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat Lab"},{"location":"lessons/04-red-green-blue/","text":"","title":"Red, Green and Blue"},{"location":"lessons/05-color-wheel/","text":"Color Wheel Lab What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red Full Program This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Color Wheel"},{"location":"lessons/05-color-wheel/#color-wheel-lab","text":"What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red","title":"Color Wheel Lab"},{"location":"lessons/05-color-wheel/#full-program","text":"This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Full Program"},{"location":"lessons/06-linear-dimmer/","text":"Linear Dimmer We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html Gamma Correction Table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"A Better Dimmer"},{"location":"lessons/06-linear-dimmer/#linear-dimmer","text":"We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html","title":"Linear Dimmer"},{"location":"lessons/06-linear-dimmer/#gamma-correction-table","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"Gamma Correction Table"},{"location":"lessons/07-motion/","text":"Motion Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period. Move a Red Pixel The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move. Experiments Change the Delay Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay. Down and Back Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) Advanced Lab: Timeing the Write You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay. Have Some Fun! Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Basic Motion"},{"location":"lessons/07-motion/#motion","text":"Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period.","title":"Motion"},{"location":"lessons/07-motion/#move-a-red-pixel","text":"The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move.","title":"Move a Red Pixel"},{"location":"lessons/07-motion/#experiments","text":"","title":"Experiments"},{"location":"lessons/07-motion/#change-the-delay","text":"Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay.","title":"Change the Delay"},{"location":"lessons/07-motion/#down-and-back","text":"Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 )","title":"Down and Back"},{"location":"lessons/07-motion/#advanced-lab-timeing-the-write","text":"You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay.","title":"Advanced Lab: Timeing the Write"},{"location":"lessons/07-motion/#have-some-fun","text":"Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Have Some Fun!"},{"location":"lessons/08-color-wipe/","text":"Color Wipe This lesson shows you how to change the color of the entire LED strip pixel by pixel. There will be two delays that we can control: the delay between each pixel update - this is usually about 1/20th of a second the delay between colors - this is usually about 1 to 2 seconds A Simple Color Wipe Function To write this program, we will create a simple Python function that will cycle through all the colors in a list. Our color list will look like this: 1 2 3 4 5 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) ... etc ... colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) Now with this list 1 2 3 4 5 6 7 8 9 def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () # the delay between each pixel draw sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from time import sleep # most people have a heart rate of around 60-70 beats per minute # If you add a once second deplay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 60 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) while True : color_wipe ( . 05 , 1 )","title":"Color Wipe"},{"location":"lessons/08-color-wipe/#color-wipe","text":"This lesson shows you how to change the color of the entire LED strip pixel by pixel. There will be two delays that we can control: the delay between each pixel update - this is usually about 1/20th of a second the delay between colors - this is usually about 1 to 2 seconds","title":"Color Wipe"},{"location":"lessons/08-color-wipe/#a-simple-color-wipe-function","text":"To write this program, we will create a simple Python function that will cycle through all the colors in a list. Our color list will look like this: 1 2 3 4 5 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) ... etc ... colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) Now with this list 1 2 3 4 5 6 7 8 9 def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () # the delay between each pixel draw sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from time import sleep # most people have a heart rate of around 60-70 beats per minute # If you add a once second deplay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 60 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) def color_wipe ( delay , color_delay ): for color in colors : for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = color strip . write () sleep ( delay ) # how long to pause between color changes sleep ( color_delay ) while True : color_wipe ( . 05 , 1 )","title":"A Simple Color Wipe Function"},{"location":"lessons/09-comet-tail/","text":"Comet Tail In this lesson we will make a pattern of light like a comet tail. The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet. The Draw Comet Tail Function Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet. In general, each pixel will be half as bright and the prior pixel. The \"levels\" of brightness can be stored in a list or calculated. Our list will look like this: 1 2 # brightness levels starting with max and going to 1 levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] Our function will have three parameters: The offset from pixel 0 The color to draw the pixel as a tuple of three integers The delay between the draws which will control the speed that the comet appears to move down the strip Here is an example of this function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): % make sure we are within the range of the LED strip offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) # set the target and scale and round to the interger value strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) The most complex line is this one: 1 strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) This line sets the RGB values of the target. It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet. After it does the multiplication, it must use the int() function to round the value to the nearest integer. Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , white ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for color_index in range ( 0 , color_count ): for i in range ( 0 , NUMBER_PIXELS ): draw_comet_tail ( counter , colors [ color_index ], . 005 ) counter += 1 print ( counter )","title":"Commit Tail"},{"location":"lessons/09-comet-tail/#comet-tail","text":"In this lesson we will make a pattern of light like a comet tail. The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet.","title":"Comet Tail"},{"location":"lessons/09-comet-tail/#the-draw-comet-tail-function","text":"Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet. In general, each pixel will be half as bright and the prior pixel. The \"levels\" of brightness can be stored in a list or calculated. Our list will look like this: 1 2 # brightness levels starting with max and going to 1 levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] Our function will have three parameters: The offset from pixel 0 The color to draw the pixel as a tuple of three integers The delay between the draws which will control the speed that the comet appears to move down the strip Here is an example of this function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): % make sure we are within the range of the LED strip offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) # set the target and scale and round to the interger value strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) The most complex line is this one: 1 strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) This line sets the RGB values of the target. It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet. After it does the multiplication, it must use the int() function to round the value to the nearest integer.","title":"The Draw Comet Tail Function"},{"location":"lessons/09-comet-tail/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) red = ( 255 , 0 , 0 ) orange = ( 140 , 60 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) white = ( 128 , 128 , 128 ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , white ) color_count = len ( colors ) levels = [ 255 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ] level_count = len ( levels ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) # offset should be incremented by one for motion def draw_comet_tail ( offset , color , delay ): offset = offset % NUMBER_PIXELS for i in range ( 0 , color_count ): target = (( level_count - i - 1 ) + offset ) % NUMBER_PIXELS # number to scale by scale = ( levels [ i ] / 255 ) strip [ target ] = ( int ( color [ 0 ] * scale ), int ( color [ 1 ] * scale ), int ( color [ 2 ] * scale )) if offset > 0 : strip [ offset - 1 ] = ( 0 , 0 , 0 ) if offset == NUMBER_PIXELS - 1 : strip [ offset ] = ( 0 , 0 , 0 ) strip . write () sleep ( delay ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for color_index in range ( 0 , color_count ): for i in range ( 0 , NUMBER_PIXELS ): draw_comet_tail ( counter , colors [ color_index ], . 005 ) counter += 1 print ( counter )","title":"Full Program"},{"location":"lessons/10-moving-rainbow/","text":"Moving Rainbow In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab. The Classic Rainbow Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors. Repeating the Moving Rainbow Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop. Improving on the Moving Rainbow This program is simple to read, but there are several ways we could improve it. One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip. This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd. For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip. We can achieve this by using the modulo function. It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#moving-rainbow","text":"In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab.","title":"Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#the-classic-rainbow","text":"Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors.","title":"The Classic Rainbow"},{"location":"lessons/10-moving-rainbow/#repeating-the-moving-rainbow","text":"Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop.","title":"Repeating the Moving Rainbow"},{"location":"lessons/10-moving-rainbow/#improving-on-the-moving-rainbow","text":"This program is simple to read, but there are several ways we could improve it. One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip. This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd. For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip. We can achieve this by using the modulo function. It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Improving on the Moving Rainbow"},{"location":"lessons/11-rainbow-cycle/","text":"Rainbow Cycle In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow. The Rainbow Cycle Function We create a function called rainbow_cycle() that has three parameters. The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over. 1 2 3 4 5 6 7 8 9 10 def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) Next, we place a while True() loop at end and call the function repeatedly. Power Considerations This program has the ability to drive every single pixel on the strip. This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply. To get around this you can up the skip parameter to only turn on every 2nd, 3rd or 4th pixel. The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts. Full Program Here is the full program you can run. Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) # s[eed is an integer from 1 to 30 speed = 2 # skip = 1 is every pixel, 2 is every other pixel etc. # the hither skip the lower the overall power skip = 3 while True : rainbow_cycle ( . 01 , speed , skip )","title":"Rainbow Cycle"},{"location":"lessons/11-rainbow-cycle/#rainbow-cycle","text":"In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow.","title":"Rainbow Cycle"},{"location":"lessons/11-rainbow-cycle/#the-rainbow-cycle-function","text":"We create a function called rainbow_cycle() that has three parameters. The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over. 1 2 3 4 5 6 7 8 9 10 def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) Next, we place a while True() loop at end and call the function repeatedly.","title":"The Rainbow Cycle Function"},{"location":"lessons/11-rainbow-cycle/#power-considerations","text":"This program has the ability to drive every single pixel on the strip. This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply. To get around this you can up the skip parameter to only turn on every 2nd, 3rd or 4th pixel. The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts.","title":"Power Considerations"},{"location":"lessons/11-rainbow-cycle/#full-program","text":"Here is the full program you can run. Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait , speed , skip ): global NUMBER_PIXELS , strip # get a color - speed will skip intermediate colors for faster cycles for j in range ( 0 , 255 , speed ): for i in range ( 0 , NUMBER_PIXELS , skip ): rc_index = ( i * 256 // NUMBER_PIXELS ) + j # print(rc_index) strip [ i ] = wheel ( rc_index & 255 ) strip . write () sleep ( wait ) # s[eed is an integer from 1 to 30 speed = 2 # skip = 1 is every pixel, 2 is every other pixel etc. # the hither skip the lower the overall power skip = 3 while True : rainbow_cycle ( . 01 , speed , skip )","title":"Full Program"},{"location":"lessons/15-random/","text":"Random Drawing In this lesson we will introduce the ability to draw random colors at random pixels. This allows us to create more natural patterns such as the flicking light of a candle. The Random Functions We need a function that will generate a random integer between a range of values. This is called the randint() function and it takes either one or two parameters. In our case, we can just pass in the minimum and maximum values: 1 randint ( 0 , 256 ) You can read more about MicroPython random functions here To use the random function we first need to import the function from the library: 1 from urandom import randint Here is a sample loop that sets each pixel to a random color using the wheel() function: 1 2 3 4 5 for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 ) Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 ) Exercises Instead of updating a single pixel in consecutive sequences, can you also use the randint() function to update a random pixel? What if you have a small fixed list of colors to pick from. How can you use randint() to pick a color from this list?","title":"Random"},{"location":"lessons/15-random/#random-drawing","text":"In this lesson we will introduce the ability to draw random colors at random pixels. This allows us to create more natural patterns such as the flicking light of a candle.","title":"Random Drawing"},{"location":"lessons/15-random/#the-random-functions","text":"We need a function that will generate a random integer between a range of values. This is called the randint() function and it takes either one or two parameters. In our case, we can just pass in the minimum and maximum values: 1 randint ( 0 , 256 ) You can read more about MicroPython random functions here To use the random function we first need to import the function from the library: 1 from urandom import randint Here is a sample loop that sets each pixel to a random color using the wheel() function: 1 2 3 4 5 for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 )","title":"The Random Functions"},{"location":"lessons/15-random/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def clear (): for i in range ( 0 , NUMBER_PIXELS ): strip [ i ] = ( 0 , 0 , 0 ) strip . write () # setup counter = 0 clear () # main loop while True : for i in range ( 0 , NUMBER_PIXELS ): random_color = randint ( 0 , 256 ) strip [ i ] = wheel ( random_color ) strip . write () sleep ( . 1 )","title":"Full Program"},{"location":"lessons/15-random/#exercises","text":"Instead of updating a single pixel in consecutive sequences, can you also use the randint() function to update a random pixel? What if you have a small fixed list of colors to pick from. How can you use randint() to pick a color from this list?","title":"Exercises"},{"location":"lessons/16-candle/","text":"Candle Flicker In this lesson we will try to simulate the behavior of a flickering candle using the randint() function. To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary. This will give the impression of a candle flame with a flicker. A pure yellow color has both the red and green values on and the blue value off: 1 2 yellow = ( 255 , 255 , 0 ) orange = ( 255 , 150 , 0 ) Our goal is to generate variations in both color and brightness. We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50. Sample Candle Function Our function will draw the new value on a random location on the LED strip. It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second. 1 2 3 4 5 6 7 def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) Full Demonstration Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint # https://docs.micropython.org/en/latest/library/random.html NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) counter = 0 while True : candle ( . 01 ) # wrap counter = counter % ( NUMBER_PIXELS - 1 ) counter += 1","title":"Candle Flicker"},{"location":"lessons/16-candle/#candle-flicker","text":"In this lesson we will try to simulate the behavior of a flickering candle using the randint() function. To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary. This will give the impression of a candle flame with a flicker. A pure yellow color has both the red and green values on and the blue value off: 1 2 yellow = ( 255 , 255 , 0 ) orange = ( 255 , 150 , 0 ) Our goal is to generate variations in both color and brightness. We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50.","title":"Candle Flicker"},{"location":"lessons/16-candle/#sample-candle-function","text":"Our function will draw the new value on a random location on the LED strip. It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second. 1 2 3 4 5 6 7 def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay )","title":"Sample Candle Function"},{"location":"lessons/16-candle/#full-demonstration-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint # https://docs.micropython.org/en/latest/library/random.html NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def candle ( delay ): for i in range ( 0 , NUMBER_PIXELS ): green = 50 + randint ( 0 , 155 ) red = green + randint ( 25 , 50 ) strip [ randint ( 0 , NUMBER_PIXELS - 1 )] = ( red , green , 0 ) strip . write () sleep ( delay ) counter = 0 while True : candle ( . 01 ) # wrap counter = counter % ( NUMBER_PIXELS - 1 ) counter += 1","title":"Full Demonstration Program"}]}