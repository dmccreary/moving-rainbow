{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MicroPython Moving Rainbow documentation! Learning to program using LED strips version 2 ''' Note! We are no longer accepting pull request for Arduino C code. Due to the fact that we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python. About Moving Rainbow Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build an entire costume with 100s of LEDs for under $20 Getting Started Addressable LED Strips Addressable LED strips are easy to connect to your project since they only need three wires (Ground, +5V and data). LED strip can be purchased on sites like ebay.com for under $5/meter of 60 RGB LEDs. References CoderDoj CoderDojo Twin Cities CodeSavvy Raspberry Pi Pico The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor. Breadboards In our projects we use 1/2 sized breadboard with 400 tie points. Mode Buttons A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode. Programming the LED strip Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Moving Rainbow Home"},{"location":"#welcome-to-the-micropython-moving-rainbow-documentation","text":"Learning to program using LED strips version 2 ''' Note! We are no longer accepting pull request for Arduino C code. Due to the fact that we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python.","title":"Welcome to the MicroPython Moving Rainbow documentation!"},{"location":"#about-moving-rainbow","text":"Moving Rainbow is a way to learn the basics of programming using LED strips. We use low-cost components so you can build an entire costume with 100s of LEDs for under $20","title":"About Moving Rainbow"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#addressable-led-strips","text":"Addressable LED strips are easy to connect to your project since they only need three wires (Ground, +5V and data). LED strip can be purchased on sites like ebay.com for under $5/meter of 60 RGB LEDs.","title":"Addressable LED Strips"},{"location":"#references","text":"CoderDoj CoderDojo Twin Cities CodeSavvy","title":"References"},{"location":"#raspberry-pi-pico","text":"The Raspberry Pi Pico cost only $4 and runs Python. All our labs use this processor.","title":"Raspberry Pi Pico"},{"location":"#breadboards","text":"In our projects we use 1/2 sized breadboard with 400 tie points.","title":"Breadboards"},{"location":"#mode-buttons","text":"A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip. Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program. In this section we will add two mode buttons. One button will make the pattern mode go to the next mode. The other button will go to the previous mode.","title":"Mode Buttons"},{"location":"#programming-the-led-strip","text":"Each of our example programs will have at least three sections: The preamble - this constains the library directives and initialization of static unchanging variables The setup() function - this function is run once with the Arduion first starts up The loop function - this function runs continually as long at the Arduino has power Sample Blink Program 1","title":"Programming the LED strip"},{"location":"getting-started/desktop-setup/","text":"Desktop Setup In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons. About Thonny Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi. Step 1: Install Thonny The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software. Thonny Versions These labs have all been tested on Thonny Version 4.0.4 . Step 2: Configure the MicroPython Firmware After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware. Manually Downloading the Firmware There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware Step 3: Configure Interpreter Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected. Thonny Firmware List After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#desktop-setup","text":"In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE). We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.","title":"Desktop Setup"},{"location":"getting-started/desktop-setup/#about-thonny","text":"Thonny is an ideal tool for writing MicroPython code for students just getting started. It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.","title":"About Thonny"},{"location":"getting-started/desktop-setup/#step-1-install-thonny","text":"The installation of Thonny will vary depending on the type of computer you are using. For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page : For all the versions of Linux, you can open the command shell an type in the correct installation command. For people using the Raspberry Pi operating system, Thonny may already be included in your software.","title":"Step 1: Install Thonny"},{"location":"getting-started/desktop-setup/#thonny-versions","text":"These labs have all been tested on Thonny Version 4.0.4 .","title":"Thonny Versions"},{"location":"getting-started/desktop-setup/#step-2-configure-the-micropython-firmware","text":"After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico. This just takes a minute and you will only have to do it once for each microcontroller. Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.","title":"Step 2: Configure the MicroPython Firmware"},{"location":"getting-started/desktop-setup/#manually-downloading-the-firmware","text":"There are occasions that the automatic firmware download in Thonny may not work. In this case you will need to manually download the firmware from the MicroPython web site. Here are the links to the Pico Firmware (called RP2-pico): Raspberry Pi Pico Firmware","title":"Manually Downloading the Firmware"},{"location":"getting-started/desktop-setup/#step-3-configure-interpreter","text":"Thonny is designed to automatically detect the correct device and configure the right interpreter. You can verify this by using the Thonny Options menu and move to the Interperter tab. Note that the MicroPython (Raspberry Pi Pico) is selected.","title":"Step 3: Configure Interpreter"},{"location":"getting-started/desktop-setup/#thonny-firmware-list","text":"After you select a rutime version, Thonny will give you the details about this version. After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware. This makes the USB drive appear to be removed without a disconnect and results in an error. This is normal so don't worry.","title":"Thonny Firmware List"},{"location":"getting-started/kits/","text":"Moving Rainbow Kits These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10 Our standard kit contains the following parts: A Raspberry Pi Pico ($4) A 1/2 size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires Classroom will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac you will need USB-C-to micro-USB connector. If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern) LED Strip","title":"Standard Kits"},{"location":"getting-started/kits/#moving-rainbow-kits","text":"These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip. The total parts cost is typically under $10 Our standard kit contains the following parts: A Raspberry Pi Pico ($4) A 1/2 size solderless breadboard (400 ties) ($2) A 30-pixel addressable RGB LED strip (WS2812B) ($2) 3 terminal screw header (optional) Two momentary push buttons 22 gauge wires Classroom will also have the right USB cables for these boards. If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac you will need USB-C-to micro-USB connector. If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones. We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern)","title":"Moving Rainbow Kits"},{"location":"getting-started/kits/#led-strip","text":"","title":"LED Strip"},{"location":"getting-started/parts/","text":"Purchasing Your Own Parts In many school based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guild is for parents and students that would like to build your own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on on-line sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these site change frequently. Soldering Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school. MicroControllers Raspberry Pi Pico We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins. NeoPixels Header Pins If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip NeoPixel Rings Raspberry Pi Pico Breadboards Momentary Push Buttons Boxes Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits. MicroPython Site For more parts, see the MicroPython site here:","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#purchasing-your-own-parts","text":"In many school based programs and coding clubs, the parts used in these lessons will be purchased for you. Very often they will be pre-assembled and all the software preloaded before the classes begin. This guild is for parents and students that would like to build your own systems at home. You can easily create your own projects based on the Moving Rainbow kits and software. You can do this by purchasing parts on on-line sites such as e-Bay or Amazon. If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon. This guide provides sample links to both e-Bay and Amazon, but we aware that these site change frequently.","title":"Purchasing Your Own Parts"},{"location":"getting-started/parts/#soldering","text":"Many of the parts you purchase online might require some soldering to make them easy to use. We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder. Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school.","title":"Soldering"},{"location":"getting-started/parts/#microcontrollers","text":"","title":"MicroControllers"},{"location":"getting-started/parts/#raspberry-pi-pico","text":"We use the Raspberry Pi Pico (far left) because it only costs about $4. It also mounts directly on the breadboard after we add the header pins.","title":"Raspberry Pi Pico"},{"location":"getting-started/parts/#neopixels","text":"","title":"NeoPixels"},{"location":"getting-started/parts/#header-pins","text":"If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11. 100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip","title":"Header Pins"},{"location":"getting-started/parts/#neopixel-rings","text":"","title":"NeoPixel Rings"},{"location":"getting-started/parts/#raspberry-pi-pico_1","text":"","title":"Raspberry Pi Pico"},{"location":"getting-started/parts/#breadboards","text":"","title":"Breadboards"},{"location":"getting-started/parts/#momentary-push-buttons","text":"","title":"Momentary Push Buttons"},{"location":"getting-started/parts/#boxes","text":"Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends. We use clear boxes that you can purchase at The Container Store Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084 These boxes have a clear detachable lid that shows off the interior wiring of their kits.","title":"Boxes"},{"location":"getting-started/parts/#micropython-site","text":"For more parts, see the MicroPython site here:","title":"MicroPython Site"},{"location":"lessons/","text":"Moving Rainbow Lessons Blink Fade In and Out Heartbeat Red, Green and Blue Color Wheel Moving Pixel Swipe","title":"Moving Rainbow Lessons"},{"location":"lessons/#moving-rainbow-lessons","text":"Blink Fade In and Out Heartbeat Red, Green and Blue Color Wheel Moving Pixel Swipe","title":"Moving Rainbow Lessons"},{"location":"lessons/01-blink/","text":"Blink Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 ) Exercises Change the Color Lab Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens? Change the Position Lab Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens? Change the Sleep Time What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005 RGB Lab Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened? Why Do We Need Strip.Write? Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line? LED Strip State What happens if you stop the program when the LED strip LEDs are on? On Your Own What if you extended the lab to more positions and colors?","title":"Blink"},{"location":"lessons/01-blink/#blink","text":"Here is one of simplest moving rainbow programs. It is our version of \"Hello World!. Our first program will just blink the first pixel on and off every 1/2 second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) while True : # turn first red pixel on for 1/2 second strip [ 0 ] = ( 255 , 0 , 0 ) strip . write () sleep ( . 5 ) # turn off for 1/2 second strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( . 5 )","title":"Blink"},{"location":"lessons/01-blink/#exercises","text":"","title":"Exercises"},{"location":"lessons/01-blink/#change-the-color-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[0] = (0,255,0) What happens?","title":"Change the Color Lab"},{"location":"lessons/01-blink/#change-the-position-lab","text":"Change the line: strip[0] = (255,0,0) to be: strip[1] = (255,0,0) What happens?","title":"Change the Position Lab"},{"location":"lessons/01-blink/#change-the-sleep-time","text":"What happens if you change the sleep time? from: sleep(.5) to: sleep(.1) What is the smallest time you can use and still see flashing? Hint: Try values like .05 , or .005","title":"Change the Sleep Time"},{"location":"lessons/01-blink/#rgb-lab","text":"Change the line: strip[0] = (255,0,0) to be: 1 2 3 strip [ 0 ] = ( 255 , 0 , 0 ) strip [ 1 ] = ( 0 , 255 , 0 ) strip [ 2 ] = ( 0 , 0 , 255 ) and change the 1 2 3 strip [ 0 ] = ( 0 , 0 , 0 ) strip [ 1 ] = ( 0 , 0 , 0 ) strip [ 2 ] = ( 0 , 0 , 0 ) What happened?","title":"RGB Lab"},{"location":"lessons/01-blink/#why-do-we-need-stripwrite","text":"Try to remove one of the line that does strip.write(). What happens? Why do you think we need this line?","title":"Why Do We Need Strip.Write?"},{"location":"lessons/01-blink/#led-strip-state","text":"What happens if you stop the program when the LED strip LEDs are on?","title":"LED Strip State"},{"location":"lessons/01-blink/#on-your-own","text":"What if you extended the lab to more positions and colors?","title":"On Your Own"},{"location":"lessons/02-fade-in-and-out/","text":"Fade In and Out Lab What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out"},{"location":"lessons/02-fade-in-and-out/#fade-in-and-out-lab","text":"What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer? To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from neopixel import NeoPixel from time import sleep NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) # the time between each of the 255 brightness steps delay = . 01 while True : # slowly get brighter for i in range ( 0 , 255 ): strip [ 0 ] = ( i , 0 , 0 ) # red=255, green and blue are 0 strip . write () # send the data from RAM down the wire sleep ( delay ) # slowly get dimmer for i in range ( 255 , 0 , - 1 ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( delay )","title":"Fade In and Out Lab"},{"location":"lessons/03-heartbeat/","text":"Heartbeat Lab What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat"},{"location":"lessons/03-heartbeat/#heartbeat-lab","text":"What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below. The following code emulates this heart beat pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from neopixel import NeoPixel from time import sleep # Most people have a heart rate of around 60-70 beats per minute # If we add a once second delay between \"beats\" you can make and LED # look like a beating heart. NUMBER_PIXELS = 1 LED_PIN = 0 strip = NeoPixel ( machine . Pin ( LED_PIN ), NUMBER_PIXELS ) ramp_delay = . 001 beat_delay = 1 skip_interval = 10 while True : # ramp brightness up using the ramp_delay for i in range ( 0 , 255 , skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) # ramp brightness down using the same delay for i in range ( 255 , 0 , - skip_interval ): strip [ 0 ] = ( i , 0 , 0 ) strip . write () sleep ( ramp_delay ) strip [ 0 ] = ( 0 , 0 , 0 ) strip . write () sleep ( beat_delay )","title":"Heartbeat Lab"},{"location":"lessons/04-red-green-blue/","text":"","title":"Red, Green and Blue"},{"location":"lessons/05-color-wheel/","text":"Color Wheel Lab What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red Full Program This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Color Wheel"},{"location":"lessons/05-color-wheel/#color-wheel-lab","text":"What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow? What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value. This is known as the `wheel function: 1 2 3 4 5 6 7 8 9 10 11 12 def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) If you follow the code, you will see that the colors range from red through green and to blue and back to red: 1 2 3 4 wheel ( 1 ) = ( 255 , 0 , 0 ) # red wheel ( 85 ) = ( 0 , 255 , 0 ) # green wheel ( 170 ) = ( 0 , 0 , 255 ) # blue wheel ( 255 ) = ( 255 , 0 , 0 ) # red","title":"Color Wheel Lab"},{"location":"lessons/05-color-wheel/#full-program","text":"This program will continu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import machine from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 1 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colors are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) counter = 0 while True : strip [ 0 ] = wheel ( counter ) strip . write () sleep ( . 01 ) counter += 1 # reset the counter if counter == 255 : counter = 0","title":"Full Program"},{"location":"lessons/06-linear-dimmer/","text":"Linear Dimmer We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html Gamma Correction Table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"A Better Dimmer"},{"location":"lessons/06-linear-dimmer/#linear-dimmer","text":"We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness. https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html","title":"Linear Dimmer"},{"location":"lessons/06-linear-dimmer/#gamma-correction-table","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gamma8 = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 15 , 15 , 16 , 16 , 17 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 22 , 22 , 23 , 24 , 24 , 25 , 25 , 26 , 27 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 32 , 33 , 34 , 35 , 35 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 50 , 51 , 52 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 77 , 78 , 79 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 92 , 93 , 95 , 96 , 98 , 99 , 101 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 114 , 115 , 117 , 119 , 120 , 122 , 124 , 126 , 127 , 129 , 131 , 133 , 135 , 137 , 138 , 140 , 142 , 144 , 146 , 148 , 150 , 152 , 154 , 156 , 158 , 160 , 162 , 164 , 167 , 169 , 171 , 173 , 175 , 177 , 180 , 182 , 184 , 186 , 189 , 191 , 193 , 196 , 198 , 200 , 203 , 205 , 208 , 210 , 213 , 215 , 218 , 220 , 223 , 225 , 228 , 231 , 233 , 236 , 239 , 241 , 244 , 247 , 249 , 252 , 255 ] 1 2 3 4 ## Gamma Correction Function # input is an integer from 0 to 255 def gamma8 ( input ): return gamma8 [ input ]","title":"Gamma Correction Table"},{"location":"lessons/07-motion/","text":"Motion Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period. Move a Red Pixel The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move. Experiments Change the Delay Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay. Down and Back Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) Advanced Lab: Timeing the Write You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay. Have Some Fun! Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Basic Motion"},{"location":"lessons/07-motion/#motion","text":"Turning individual pixels on and off is pretty easy. But the results can be pretty boring after a while. But don't worry, we can now create a program that is a lot more fun! This program uses the Python for loop. It uses a counter, called an index, to turn on successive pixels in the strip. For each pixel it turn it on, delays for a short period of time, and then turns it off. It then moves on to the next pixel until each pixel is the strip has been turned on for short period.","title":"Motion"},{"location":"lessons/07-motion/#move-a-red-pixel","text":"The following program illustrates this process. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a variable to store the delay delay = . 03 while True : for i in range ( 0 , NUMBER_PIXELS - 1 ): # turn index red pixel on for a short delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) # turn off strip [ i ] = ( 0 , 0 , 0 ) You will note that this program is similar to the blink lab with a few key differences: The code that turns the pixel on and off is inside the for loop. There is no delay or write after we turn it off. You could add these back in, but they are not really needed. Note that the delary time in this program is stored in the delay variable and it is a pretty short delay. The shorter the delay, the faster the pixel will appear to move.","title":"Move a Red Pixel"},{"location":"lessons/07-motion/#experiments","text":"","title":"Experiments"},{"location":"lessons/07-motion/#change-the-delay","text":"Try to change the delay variable to different values. Note how slow the pixel moves if you make the delay a full second. This is pretty boring. Change the delay to be .01. This is 1/100th of a second. What is the fastest you can make the pixel move? What happens if you make the delay less than .001 . Can you still notice the change in the speed? Many people can't tell the difference because the time to do the strip.write() function is much longer than the delay.","title":"Change the Delay"},{"location":"lessons/07-motion/#down-and-back","text":"Next, lets try to make the pixel appear to move down the LED strip and then back up. We call this the \"Down and Back\" pattern. To do this we just need to duplicate the for loop, but change the range of the index. Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from neopixel import NeoPixel from utime import sleep NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Create a varuabke to store the delay delay = . 01 while True : # move down for i in range ( 0 , NUMBER_PIXELS - 1 ): strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 ) # move back for i in range ( NUMBER_PIXELS - 1 , 0 , - 1 ): # turn index red pixel on for and delay strip [ i ] = ( 255 , 0 , 0 ) strip . write () sleep ( delay ) strip [ i ] = ( 0 , 0 , 0 )","title":"Down and Back"},{"location":"lessons/07-motion/#advanced-lab-timeing-the-write","text":"You can measure the time it takes do perform the strip.write() by recording the number of \"ticks\" before and after the write. See the function time.ticks_us() for details. 1 2 3 4 5 6 7 8 9 10 11 from neopixel import NeoPixel from utime import sleep , ticks_us NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) start = ticks_us () strip . write () print ( ticks_us () - start ) On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds. The shorter the LED strip, the shorter the delay. Longer LED strips will have a correspondingly longer delay.","title":"Advanced Lab: Timeing the Write"},{"location":"lessons/07-motion/#have-some-fun","text":"Try to change the color of the pixel. Try to change the direction of motion from the last to the beginning pixel. Try making the","title":"Have Some Fun!"},{"location":"lessons/08-moving-rainbow/","text":"Moving Rainbow In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab. The Classic Rainbow Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors. Repeating the Moving Rainbow Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop. Improving on the Moving Rainbow This program is simple to read, but there are several ways we could improve it. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Moving Rainbow"},{"location":"lessons/08-moving-rainbow/#moving-rainbow","text":"In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip. This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip. We will begin with drawing a static hand-built list of colors on our strip. We call this doing it \"the hard way\". After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab.","title":"Moving Rainbow"},{"location":"lessons/08-moving-rainbow/#the-classic-rainbow","text":"Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet. We can lookup the red, green and blue values of these colors on Wikipedia . Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 We can then put the colors into a Python data structure called a list: 1 2 3 4 5 6 7 8 9 10 11 # Color RGB values as tuples red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 238 , 130 , 238 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) We can then draw these colors in each of the first seven pixels like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) index = 0 for color in colors : strip [ index ] = colors [ index ] index += 1 strip . write () Here is the important new line: 1 strip [ index ] = colors [ index ] It says, for the current index, set the strip value to the three values in the colors list. We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) There are a few tricky adjustments we had to make: We added the index counter to the strip index so that we would start drawing at a different point each time. We had to not go to the end of the LED strip. We had to stop num_colors + 1 before the end of the strip. We had to erase the current pixel after we drew the colors.","title":"The Classic Rainbow"},{"location":"lessons/08-moving-rainbow/#repeating-the-moving-rainbow","text":"Finally, we can wrap this entire section in a while True loop that will keep running the pattern over and over. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from neopixel import NeoPixel from utime import sleep , sleep_ms NEOPIXEL_PIN = 0 NUMBER_PIXELS = 60 strip = NeoPixel ( machine . Pin ( NEOPIXEL_PIN ), NUMBER_PIXELS ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) while True : for i in range ( 0 , NUMBER_PIXELS - num_colors + 1 ): index = 0 # draw the rainbow for color in colors : strip [ index + i ] = colors [ index ] index += 1 strip . write () sleep ( . 05 ) # erase the current pixel strip [ i ] = ( 0 , 0 , 0 ) # erase the last draw if i == NUMBER_PIXELS - num_colors : strip [ i + 1 ] = ( 0 , 0 , 0 ) strip [ i + 2 ] = ( 0 , 0 , 0 ) strip [ i + 3 ] = ( 0 , 0 , 0 ) strip [ i + 4 ] = ( 0 , 0 , 0 ) strip [ i + 5 ] = ( 0 , 0 , 0 ) strip [ i + 6 ] = ( 0 , 0 , 0 ) strip . write () Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop.","title":"Repeating the Moving Rainbow"},{"location":"lessons/08-moving-rainbow/#improving-on-the-moving-rainbow","text":"This program is simple to read, but there are several ways we could improve it. What if we wanted our rainbow to be a different number of pixels? It would be ideal of we could just write a function that would draw the right pixels at the right place. Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?","title":"Improving on the Moving Rainbow"}]}