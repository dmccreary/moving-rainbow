{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the MicroPython Moving Rainbow Website!","text":""},{"location":"#about-the-moving-rainbow-project","title":"About the Moving Rainbow Project","text":"<p>Moving Rainbow is a way to learn the basics of programming using LED strips.  We use low-cost components so you can build entire projects and costumes with 100s of LEDs for under $20.  Since 2014 we have been building low-cost kits that teach all the concepts of Computational Thinking](https://www.coderdojotc.org/CoderDojoTC/computational-thinking/).</p> <p>Note</p> <p>We are no longer accepting pull requests for Arduino C code.  Because we can get Raspberry Pi Pico processors for $4 that run Python we have moved all our Moving Rainbow code over to Python.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Our getting started guide has three parts:</p> <ol> <li>About Moving Rainbow</li> <li>Code Savvy Kits</li> <li>Build Your Own from Parts</li> <li>Desktop Setup</li> </ol>"},{"location":"#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>The Raspberry Pi Pico cost only $4 and runs Python.  All our labs use this processor.</p>"},{"location":"#breadboards","title":"Breadboards","text":"<p>In our projects we use 1/2 sized breadboard with 400 tie points.</p> <p></p>"},{"location":"#mode-buttons","title":"Mode Buttons","text":"<p>A \"mode\" is a way of having a single Arduino program run multiple patterns on the LED strip.  Each mode has a number associated with it starting with 0 and continuing to the number of patterns we have in our program.</p> <p>In this section we will add two mode buttons.  One button will make the pattern mode go to the next mode.  The other button will go to the previous mode.</p>"},{"location":"#programming-the-led-strip","title":"Programming the LED strip","text":"<p>Each of our example programs will have at least three sections:</p> <ol> <li>The preamble - this constains the library directives and initialization of static unchanging variables</li> <li>The setup() function - this function is run once with the Arduion first starts up</li> <li>The loop function - this function runs continually as long at the Arduino has power</li> </ol> <p>Sample Blink Program</p>"},{"location":"challenges/","title":"Moving Rainbow Challenges","text":"<p>They are a set of learning challenges for the LED Strip.  They are listed in order from the simplest to the most complex.</p>"},{"location":"challenges/#beginning-challenges","title":"Beginning Challenges","text":"<p>These challenges can all be done once you know the following commands:</p> <ol> <li>Initialize the NeoPixel</li> <li>Change a Pixel Color</li> <li>Write the Strip</li> <li>For Loop and range</li> <li>Sleep</li> </ol>"},{"location":"challenges/#make-a-pixel-blink","title":"Make a Pixel Blink","text":""},{"location":"challenges/#draw-an-rgb-pattern","title":"Draw an RGB Pattern","text":""},{"location":"challenges/#draw-a-rainbow","title":"Draw a Rainbow","text":""},{"location":"challenges/#make-a-pixel-fade-in-and-out-slowly","title":"Make a Pixel Fade in and Out Slowly","text":""},{"location":"challenges/#make-a-heartbeat-pattern","title":"Make a Heartbeat Pattern","text":""},{"location":"challenges/#make-a-pixel-move-down-the-strip","title":"Make a Pixel Move Down the Strip","text":""},{"location":"challenges/#change-colors-for-the-entire-led-strip-wipe","title":"Change Colors for the Entire LED Strip (wipe)","text":""},{"location":"challenges/#move-a-pixel-down-and-back","title":"Move a Pixel Down and Back","text":""},{"location":"challenges/#create-a-larson-scanner-pattern","title":"Create a Larson Scanner Pattern","text":""},{"location":"challenges/#draw-different-levels-of-brightness","title":"Draw Different Levels of Brightness","text":""},{"location":"challenges/#make-every-other-pixel-a-different-color","title":"Make Every Other Pixel a Different Color","text":""},{"location":"challenges/#intermediate-labs","title":"Intermediate Labs","text":"<p>These challenges involve more advanced programming such as using:</p> <ol> <li>Conditionals</li> <li>Modulo (remainder)</li> <li>Functions</li> <li>Multiple Loops</li> <li>Nested Loops</li> <li>Lists</li> <li>Random Numbers</li> </ol>"},{"location":"challenges/#move-the-rainbow-pattern","title":"Move the Rainbow Pattern","text":""},{"location":"challenges/#move-a-comet-pattern","title":"Move a Comet Pattern","text":""},{"location":"challenges/#create-a-list-of-named-colors","title":"Create a List of Named Colors","text":""},{"location":"challenges/#create-a-theater-chase-pattern","title":"Create a Theater Chase Pattern","text":""},{"location":"challenges/#use-the-wheel-function-to-draw-a-rainbow","title":"Use The Wheel Function to Draw a Rainbow","text":""},{"location":"challenges/#do-a-color-cycle-for-the-entire-strip","title":"Do a Color Cycle for the Entire Strip","text":""},{"location":"challenges/#draw-multiple-color-comets","title":"Draw Multiple Color Comets","text":""},{"location":"challenges/#draw-different-patterns-in-a-loop","title":"Draw Different Patterns in a Loop","text":""},{"location":"challenges/#use-random-numbers-for-color-selection","title":"Use Random Numbers for Color Selection","text":""},{"location":"challenges/#random-ripples","title":"Random Ripples","text":"<p>Draw random ripple patterns on the LED strips where the pixels move out from a single point.</p>"},{"location":"challenges/#use-random-to-simulate-candle-flicker","title":"Use Random to Simulate Candle Flicker","text":""},{"location":"challenges/#use-random-to-for-changing-move-direction","title":"Use Random to For Changing Move Direction","text":""},{"location":"challenges/#advanced-labs","title":"Advanced Labs","text":"<p>These labs may require some additional components such as:</p> <ol> <li>Buttons (momentary press)</li> <li>Potentiometers</li> <li>Speaker/Buzzer</li> <li>Interrupt Service Routines</li> <li>A USB Current Meter</li> <li>A Light Sensor (photoresistor)</li> <li>An OLED display</li> <li>A Wireless Controller</li> </ol>"},{"location":"challenges/#create-separate-python-functions-for-five-patterns","title":"Create Separate Python Functions for Five Patterns","text":""},{"location":"challenges/#create-a-mode-variable-for-switching-the-patterns","title":"Create a Mode Variable for Switching the Patterns","text":""},{"location":"challenges/#use-a-button-to-change-a-pattern-mode","title":"Use a Button to Change a Pattern Mode","text":""},{"location":"challenges/#night-light","title":"Night Light","text":"<p>Add a photoresistor that will turn the LED strip on when it is dark in the room.</p>"},{"location":"challenges/#use-potentiometers-to-change-speed","title":"Use Potentiometers to Change Speed","text":"<p>Add a potentiometer and change the speed of a display pattern</p>"},{"location":"challenges/#use-potentiometers-to-change-brightness","title":"Use Potentiometers to Change Brightness","text":"<p>Add a potentiometer and change the brightness of a display pattern</p>"},{"location":"challenges/#create-a-demo-auto-cycle-pattern-a-button-to-advance-the-mode","title":"Create a Demo Auto-Cycle Pattern a Button to Advance the Mode","text":""},{"location":"challenges/#calculate-the-power-draw-of-different-colors","title":"Calculate the Power Draw of Different Colors","text":"<p>Get a USB power meter from the instructor.  Measure the current draw for each of the different colors.  Calculate the time for a 2,500-milliamp-hour battery pack for various patterns.</p>"},{"location":"challenges/#connect-an-oled-display-that-shows-the-pattern-color-and-brightness-of-the-led-strip","title":"Connect an OLED display that shows the pattern, color and brightness of the LED strip.","text":""},{"location":"challenges/#add-buttons-to-change-the-parameters-with-the-oled","title":"Add Buttons to Change the Parameters with the OLED","text":""},{"location":"challenges/#add-a-sound","title":"Add a Sound","text":"<p>Add a speaker or buzzer to play a sound when a button is pressed.</p>"},{"location":"challenges/#simon-game","title":"Simon Game","text":"<p>Display a pattern on four pixels of the LED strip and have the user repeat the pattern using four buttons.  Play different tones for each pixel.</p>"},{"location":"challenges/#zone-game","title":"Zone Game","text":"<p>Draw a zone of a different color in the center of the strip.  Move a pixel down and strip and give a player a point if they press the button in the strip.  Use sound and pixel colors to show the points score.  Make the zone smaller and the speed faster as the game progresses.</p>"},{"location":"challenges/#random-zone","title":"Random Zone","text":"<p>Add randomization to your Zone game to make the zone move in random directions.</p>"},{"location":"challenges/#clock","title":"Clock","text":"<p>Turn your LED strip into a clock.  You can display each digit using a binary structure.</p>"},{"location":"challenges/#wireless-labs","title":"Wireless Labs","text":""},{"location":"challenges/#web-page-color-control","title":"Web Page Color Control","text":"<p>Create a web page that changes the color of the LED strip.</p>"},{"location":"challenges/#create-a-web-page-to-change-the-pattern","title":"Create a Web Page to Change the Pattern","text":"<p>Create a web page that changes the pattern</p>"},{"location":"challenges/#pattern-brightness-and-speed","title":"Pattern, Brightness and Speed","text":"<p>Create a web page that changes the pattern, brightness and speed of a pattern.</p>"},{"location":"challenges/#display-the-weather-forecast","title":"Display the Weather Forecast","text":"<p>Use a web service to get the weather forecast for the current day. Change the color of the display:</p> <ol> <li>Yellow for Sunny</li> <li>Gray for Cloudy</li> <li>Red for Rain</li> <li>White for Snow</li> </ol> <p>You can use this example to get started.</p>"},{"location":"resources/","title":"Moving Rainbow Resources","text":""},{"location":"resources/#references","title":"References","text":"<ol> <li>CodeSavvy</li> <li>CoderDojo International</li> <li>CoderDojo Twin Cities (now part of the Code Savvy Explorer Program)</li> </ol>"},{"location":"getting-started/about/","title":"About Moving Rainbow","text":"<p>What is the lowest-cost and most fun kit that teaches computational thinking?  This is the question that has been the driving force behind the Moving Rainbow project.</p> <p>We think the answer is the $10 Moving Rainbow kit.  Let us tell you why.</p>"},{"location":"getting-started/about/#background-of-the-moving-rainbow","title":"Background of the Moving Rainbow","text":"<p>In 2014 the IoT Hackday program in Minnesota was looking for a way to introduce new students to the Internet of Things and to teach computer programming with microcontrollers.  Dan McCreary developed a series of projects and tried them on in classrooms.  He quickly learned that kids loved working with LEDs and making colorful patterns with rows of LEDs.</p> <p>However, these projects required lots of individual components (LEDs, resistors, Arduino etc.).  Eventually, Dan discovered a new type of LEDs that came in long strips and each pixel contained an individually addressable red, green and blue pixel.  These projects were easy to hook up and the students could focus on programming the patterns on the LED strips.</p> <p>Dan's first \"kits\" contained an Arduino Nano and only 12 pixels.  But he could provide the kits to teachers, mentors, and students for under $25.  Since then the cost of both the microcontrollers and the LED strips have come down.  And since 2021 the curriculum has shifted from C on Arduino to Python on Picos and similar powerful but low-cost microcontrollers.</p> <p>Today, the Moving Rainbow systems include kits, instructions for building your own kits and extensive lesson plans on both the Pico and the Pico \"W\" (wireless).</p>"},{"location":"getting-started/about/#color-motion-fun-and-design","title":"Color, Motion, Fun and Design","text":"<p>So why pick this specific design?  At the center of this design is hundreds of hours of careful observation of students actually using these devices.  With each iteration, we continue to build, test, observe and change our design to meet the needs of our students.  Here is what we have learned:</p> <ol> <li>Kids love color</li> <li>Kids love motion</li> <li>Kids love to have their OWN devices to show their friends and family.  </li> </ol> <p>If they can take them home and show them off they take ownership of the skills they need to continually create and expand the features of these little devices.</p> <p>These principles are simple, but they are well-tested and we think they will persist even as technology progresses.  We expect to have more powerful devices and bigger and better displays.  But the stepping stones will remain.</p>"},{"location":"getting-started/about/#licenses","title":"Licenses","text":"<p>All Moving Rainbow curricula are licensed under Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0).  This means you can use and modify the materials in your classroom as long as you don't resell the content for profit.</p>"},{"location":"getting-started/about/#contact","title":"Contact","text":"<p>If you have further questions about the Moving Rainbow Project by contacting Dan on his LinkedIn page.  We are continually looking for schools, teachers, mentors and students that would like to promote computational thinking in our classrooms and at home.</p>"},{"location":"getting-started/connections/","title":"Circuit Connections","text":"<p>Because this guide is focused on teaching computational thinking, we don't spend much time on circuits and wiring diagrams.  We try to keep the circuits and wiring diagrams as simple as possible.</p> <p>For the basic NeoPixel strip are only three wires you need to connect only three wired for the basic project.</p> <ol> <li>The LED strip GND </li> <li>The LED strip power (+5)</li> <li>The LED strip data</li> </ol> <p></p>"},{"location":"getting-started/desktop-setup/","title":"Desktop Setup","text":"<p>In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE).  We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.</p>"},{"location":"getting-started/desktop-setup/#about-thonny","title":"About Thonny","text":"<p>Thonny is an ideal tool for writing MicroPython code for students just getting started.  It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.</p>"},{"location":"getting-started/desktop-setup/#step-1-install-thonny","title":"Step 1: Install Thonny","text":"<p>The installation of Thonny will vary depending on the type of computer you are using.  For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page:</p> <p></p> <p>For all the versions of Linux, you can open the command shell an type in the correct installation command.  For people using the Raspberry Pi operating system, Thonny may already be included in your software.</p>"},{"location":"getting-started/desktop-setup/#thonny-versions","title":"Thonny Versions","text":"<p>These labs have all been tested on Thonny Version 4.0.4.</p>"},{"location":"getting-started/desktop-setup/#step-2-configure-the-micropython-firmware","title":"Step 2: Configure the MicroPython Firmware","text":"<p>After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico.  This just takes a minute and you will only have to do it once for each microcontroller.</p> <p>Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.</p>"},{"location":"getting-started/desktop-setup/#manually-downloading-the-firmware","title":"Manually Downloading the Firmware","text":"<p>There are occasions that the automatic firmware download in Thonny may not work.  In this case you will need to manually download the firmware from the MicroPython web site.</p> <p>Here are the links to the Pico Firmware (called RP2-pico):</p> <p>Raspberry Pi Pico Firmware</p> <p></p>"},{"location":"getting-started/desktop-setup/#step-3-configure-interpreter","title":"Step 3: Configure Interpreter","text":"<p>Thonny is designed to automatically detect the correct device and configure the right interpreter.  You can verify this by using the Thonny Options menu and move to the Interperter tab.</p> <p></p> <p>Note that the MicroPython (Raspberry Pi Pico) is selected.</p>"},{"location":"getting-started/desktop-setup/#thonny-firmware-list","title":"Thonny Firmware List","text":"<p>After you select a rutime version, Thonny will give you the details about this version.</p> <p></p> <p></p> <p>After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware.  This makes the USB drive appear to be removed without a disconnect and results in an error.  This is normal so don't worry.</p> <p></p> <p></p>"},{"location":"getting-started/kits/","title":"Moving Rainbow Kits","text":"<p>These lesson plans are designed to be used with a Raspberry Pi Pico and an addressable LED strip.  The total parts cost is typically under $10</p> <p></p>"},{"location":"getting-started/kits/#standard-parts","title":"Standard Parts","text":"<p>Our standard kit contains the following parts:</p> <ol> <li>Microcontroller - A Raspberry Pi Pico ($4) or \"W\" ($6).  We often solder our own headers in, but if you are not familiar with soldering you can purchase them with header pins soldered in place.</li> <li>Breadboard - A 1/2-size solderless breadboard (400 ties) ($2)</li> <li>LED Strip - A 60-LED/meter addressable RGB LED strip (WS2812B) ($4).  We purchase 1-meter strips and cut them in half and solder connectors on the ends.  You can also purchase NeoPixel rings, arrays and fairy lights.  Fairy lights are ideal for costumes but the thin wires are easily damaged.</li> <li>Headers - 3 terminal screw headers (optional) - This makes it easier to connect and disconnect the LED strip connections without soldering.</li> <li>Buttons - Two momentary push buttons.  We purchase these in packages of 100 to keep the per-button cost down.</li> <li>Wire - 22 gauge insulated wires.  We get red, black wire for power and ground and other colors for data.  We use yellow wire for the data connections.</li> </ol>"},{"location":"getting-started/kits/#optional-parts","title":"Optional Parts","text":""},{"location":"getting-started/kits/#usb-connectors","title":"USB Connectors","text":"<p>Most of our classrooms will also have the right USB cables for these boards.  If you have a PC or a Mac you will need a USB-A-to-micro-USB or for a Mac, you will need USB-C-to-micro-USB connector.</p>"},{"location":"getting-started/kits/#batteries-and-battery-packs","title":"Batteries and Battery Packs","text":"<p>If you are using these kits to make a costume, you can also purchase a battery pack that holds 3 AA batteries or a USB power pack used to recharge phones.  We find that even the small 2,500 milliamp hour packs will power a costume of 60 LEDs for many hours (depending on the brightness of the pattern)</p>"},{"location":"getting-started/kits/#led-strip-and-rings","title":"LED Strip and Rings","text":"<p>There are hundreds of variations of WS2812B LED strips and fairy lights.  We usually purchase them in 1-meter strips with 60 pixels per meter.  Since 2020 there are now very lightweight fairy lights that are ideal for lighting up costumes.</p> <p>EBay Search for SW2812B</p> <p>If you are creating costumes that might get wet in the rain, we suggest getting the versions that are encased in a waterproof silicon tube or in a waterproof silicon coating.</p>"},{"location":"getting-started/kits/#led-fairy-lights","title":"LED Fairy Lights","text":""},{"location":"getting-started/parts/","title":"Purchasing Your Own Parts","text":"<p>In many school-based programs and coding clubs, the parts used in these lessons will be purchased for you.  Very often they will be pre-assembled and all the software preloaded before the classes begin.  This guide is for mentors, parents and students who would like to build their own systems at home.</p> <p>You can easily create your own projects based on the Moving Rainbow kits and software.  You can do this by purchasing parts on online sites such as e-Bay or Amazon.  If you are a good planner you can purchase parts from China that take longer to arrive, but they can cost significantly less than parts that ship overnight on Amazon.  This guide provides sample links to both e-Bay and Amazon, but be aware that these sites change frequently.</p>"},{"location":"getting-started/parts/#ws-2812b-led-strip","title":"WS-2812B LED Strip","text":"<p>You can purchase the LED strips for around $3.00 per meter if you shop around on e-Bay.  The above was from seller btflightingcom.  We use the 60 pixels/meter type without waterproofing for our indoor classes.  People that create costumes use the waterproof varieties.</p> <p>Some of these parts are also called \"NeoPixels\".</p> <p></p> <p>NeoPixels are parts that contain three LEDs and logic to process an incoming data stream.  Each NeoPixel will look at the incoming data and extract the 8-bit values for its own red, green and blue LED brightness.  It then sends the data signal on to the next NeoPixel.</p> <p></p>"},{"location":"getting-started/parts/#soldering","title":"Soldering","text":"<p>Many of the parts you purchase online might require some soldering to make them easy to use.  We recommend that you get a soldering iron and solder and watch a YouTube video on how to solder.  Kids should always have adult supervision and you should check with your school or classroom policy before you bring a soldering iron to school.</p>"},{"location":"getting-started/parts/#headers","title":"Headers","text":"<p>Many of the Pico's don't come with headers.  You can purchase 100 40-pin breakaway headers for about $10 dollars on e-Bay.</p> <p>Part Description: 40-Pin Male Header 0.1\" 2.54mm Connectors</p>"},{"location":"getting-started/parts/#microcontrollers","title":"MicroControllers","text":""},{"location":"getting-started/parts/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>We use the Raspberry Pi Pico (far left) because it only costs about $4.</p> <p></p> <p>It also mounts directly on the breadboard after we add the header pins.</p>"},{"location":"getting-started/parts/#neopixels","title":"NeoPixels","text":""},{"location":"getting-started/parts/#header-pins","title":"Header Pins","text":"<p>If your Microcontrollers do not come with header pins, you can purchase about 100 of them on e-Bay for about $11.</p> <p>100pcs Pitch 1x40 Pins 2.54mm Male Single Row Male Pin Header Strip</p>"},{"location":"getting-started/parts/#breadboards","title":"Breadboards","text":"<p>We use 400-tie 1/2 size breadboards.  You can purchase them on E-Bay for around $1.50 each in quantity 10.</p> <p></p>"},{"location":"getting-started/parts/#momentary-push-buttons","title":"Momentary Push Buttons","text":"<p>Tactile Switchs</p> <p></p> <p>We use these buttons </p> <p>Part Description: 100PCS B3F-4055 12127.3 Tactile Switch 12x12x7.3mm</p> <p></p> <p>The caps are 140PCS Round Tactile Button Cap Kits 9.585.1mm for 1212*7.3mm Tact Switch on eBay</p> <p></p>"},{"location":"getting-started/parts/#boxes","title":"Boxes","text":"<p>Our students love to put their projects into clear boxes so they can simply throw them in their backpacks and show their friends.  We use clear boxes that you can purchase at The Container Store</p> <p>Shallow Narrow Stackable Rectangle Clear 8-1/4\" x 3-1/2\" x 1-1/2\" h $3.99 SKU:10051084</p> <p>These boxes have a clear detachable lid that shows off the interior wiring of their kits.</p>"},{"location":"getting-started/parts/#micropython-site","title":"MicroPython Site","text":"<p>For more parts, see the CoderDojoTC MicroPython website.</p>"},{"location":"lessons/","title":"Moving Rainbow Lessons","text":""},{"location":"lessons/#simple-individual-patterns","title":"Simple Individual Patterns","text":"<ol> <li>Blink - blink the first pixel red on and off</li> <li>Fade In and Out - Make the first pixel fade in and out</li> <li>Heartbeat - Change the first red pixel to beat like a heartbeat</li> <li>Red, Green and Blue - Draw red, green and blue colors in different places</li> <li>Color Wheel - draw all the colors of the rainbow</li> <li>A Better Dimmer - making our dimmer more uniform</li> <li>Moving Pixel - move a pixel up and down the LED strip</li> <li>Color Wipe - change the color one pixel at a time</li> <li>Bounce - dots crash in the center of the strip</li> <li>Comet - make a block of color move with a dimming tail</li> <li>Moving Rainbow - move a block of colors </li> <li>Rainbow Cycle - cycle every pixel through all the colors of the rainbow</li> <li>Larson Scanner - famous Cylon eye and KITT car scanning pattern</li> <li>Random Colors - draw random colors at each pixel</li> <li>Twinkle - random pixels twinkle on for a brief second</li> <li>Ripple - simulated drops in a pond in 1-D</li> <li>Random Bounce - random points bounce around</li> <li>Candle - simulated candle flickers with randomness</li> <li>Theater Chase - classic running light patterns popular in signs</li> <li>Moving Bands - moving bands of color</li> </ol>"},{"location":"lessons/#rotating-patterns","title":"Rotating Patterns","text":"<ol> <li>Modes - assign a mode to each pattern</li> <li>Button Modes - use buttons to change a mode</li> </ol>"},{"location":"lessons/01-blink/","title":"Blink","text":"<p>Here is one of simplest moving rainbow programs.  It is our version of \"Hello World!. </p> <p>Our first program will just blink the first pixel on and off every 1/2 second.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    # turn first red pixel on for 1/2 second\n    strip[0] = (255,0,0)\n    strip.write()\n    sleep(.5)\n\n    # turn off for 1/2 second\n    strip[0] = (0,0,0)\n    strip.write()\n    sleep(.5)\n</code></pre>"},{"location":"lessons/01-blink/#exercises","title":"Exercises","text":""},{"location":"lessons/01-blink/#change-the-color-lab","title":"Change the Color Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: <code>strip[0] = (0,255,0)</code></li> </ol> <p>What happens?</p>"},{"location":"lessons/01-blink/#change-the-position-lab","title":"Change the Position Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: strip[1] = (255,0,0)</li> </ol> <p>What happens?</p>"},{"location":"lessons/01-blink/#change-the-sleep-time","title":"Change the Sleep Time","text":"<p>What happens if you change the sleep time?</p> <p>from: <code>sleep(.5)</code> to: <code>sleep(.1)</code></p> <p>What is the smallest time you can use and still see flashing?  Hint: Try values like <code>.05</code>, or <code>.005</code></p>"},{"location":"lessons/01-blink/#rgb-lab","title":"RGB Lab","text":"<ol> <li>Change the line: <code>strip[0] = (255,0,0)</code> to be: <pre><code>strip[0] = (255,0,0)\nstrip[1] = (0,255,0)\nstrip[2] = (0,0,255)\n</code></pre> and change the <pre><code>    strip[0] = (0,0,0)\n    strip[1] = (0,0,0)\n    strip[2] = (0,0,0)\n</code></pre></li> </ol> <p>What happened?</p>"},{"location":"lessons/01-blink/#why-do-we-need-stripwrite","title":"Why Do We Need Strip.Write?","text":"<p>Try to remove one of the line that does strip.write().  What happens?  Why do you think we need this line?</p>"},{"location":"lessons/01-blink/#led-strip-state","title":"LED Strip State","text":"<p>What happens if you stop the program when the LED strip LEDs are on? </p>"},{"location":"lessons/01-blink/#on-your-own","title":"On Your Own","text":"<p>What if you extended the lab to more positions and colors?</p>"},{"location":"lessons/02-fade-in-and-out/","title":"Fade In and Out Lab","text":"<p>What if instead of the first LED just turning on and off we want to slowly make the LED get brighter and then slowly dimmer?  To do this we will change the brightness of the red from off (0) to fully on (255) in steps with a small delay of 1/100th of a second between the steps.</p> <pre><code>from neopixel import NeoPixel\nfrom time import sleep\n\nNUMBER_PIXELS = 1\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\n# the time between each of the 255 brightness steps\ndelay = .01\n\nwhile True:\n    # slowly get brighter\n    for i in range(0, 255):\n        strip[0] = (i,0,0) # red=255, green and blue are 0\n        strip.write() # send the data from RAM down the wire\n        sleep(delay)\n    # slowly get dimmer\n    for i in range(255, 0, -1):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(delay)\n</code></pre>"},{"location":"lessons/03-heartbeat/","title":"Heartbeat Lab","text":"<p>What if you were building a robot and you wanted to flash the LED to look like a human heartbeat?  Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an elecrto cardiogram (EKG) and it look like this:</p> <p></p> <p>Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. We call this the skip_interval in our code below.</p> <p>The following code emulates this heart beat pattern:</p> <pre><code>from neopixel import NeoPixel\nfrom time import sleep\n\n# Most people have a heart rate of around 60-70 beats per minute\n# If we add a once second delay between \"beats\" you can make and LED\n# look like a beating heart.\n\nNUMBER_PIXELS = 1\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\nramp_delay = .001\nbeat_delay = 1\nskip_interval = 10\n\nwhile True:\n    # ramp brightness up using the ramp_delay\n    for i in range(0, 255, skip_interval):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(ramp_delay)\n    # ramp brightness down using the same delay\n    for i in range(255, 0, -skip_interval):\n        strip[0] = (i,0,0)\n        strip.write()\n        sleep(ramp_delay)\n    strip[0] = (0,0,0)\n    strip.write()\n    sleep(beat_delay)\n</code></pre>"},{"location":"lessons/04-red-green-blue/","title":"Red, Green and Blue","text":"<p>In this lesson, we will draw three different colors at three different locations on the LED strip.  We will then repeat this pattern down the strip.</p> <p>Our first task is to draw the red, green and blue in the first three pixels of the LED strip.</p> <p>Our main code will be the following</p> <pre><code># make the fist location red\nstrip[0] = (255,0,0)\n# make the second location green\nstrip[1] = (0,255,0)\n# make the third location blue\nstrip[2] = (0,0,255)\n# update the strip\nstrip.write()\n</code></pre>"},{"location":"lessons/04-red-green-blue/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# make the fist location red\nstrip[0] = (255,0,0)\n# make the second location green\nstrip[1] = (0,255,0)\n# make the third location blue\nstrip[2] = (0,0,255)\n# update the strip\nstrip.write()\n</code></pre>"},{"location":"lessons/04-red-green-blue/#repeating-the-pattern","title":"Repeating the Pattern","text":"<p>Now, let's repeat this pattern over the entire strip.  We can do this by wrapping the three lines in a for loop like this:</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# count 0 to the end skipping every 3\nfor i in range(0, NUMBER_PIXELS-1, 3):\n    strip[i] = (255,0,0)\n    # make the second location green\n    strip[i+1] = (0,255,0)\n    # make the third location blue\n    strip[i+2] = (0,0,255)\n    # update the strip\nstrip.write()\n</code></pre> <p>Note here that the range function has a third parameter that tells us how many to skip in each iteration of the loop.  Since we have three colors, we can skip every three values of i.  I will get values of 0, 3, 6, 9, 12... etc.</p>"},{"location":"lessons/04-red-green-blue/#excercises","title":"Excercises","text":""},{"location":"lessons/05-color-wheel/","title":"Color Wheel Lab","text":"<p>What if we wanted to slowly vary the color of one of our pixels through all the colors of the rainbow?  What we would like is a function that would take in an number from 0 to 255 and walk around the color wheel as you change the input value.  This is known as the <code>`wheel</code> function:</p> <pre><code>def wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n</code></pre> <p>If you follow the code, you will see that the colors range from red through green and to blue and back to red:</p> <pre><code>wheel(1) = (255, 0, 0) # red\nwheel(85) = (0,255, 0) # green\nwheel(170) = (0, 0, 255) # blue\nwheel(255) = (255, 0, 0) # red\n</code></pre>"},{"location":"lessons/05-color-wheel/#full-program","title":"Full Program","text":"<p>This program will continu</p> <pre><code>import machine\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 1\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ncounter = 0\nwhile True:\n    strip[0] = wheel(counter)\n    strip.write()\n    sleep(.01)\n    counter += 1\n    # reset the counter\n    if counter == 255:\n        counter = 0\n</code></pre>"},{"location":"lessons/06-linear-dimmer/","title":"Linear Dimmer","text":"<p>We can dim a single LED by using PWM or we can dim a NeoPixel by sending it a value from 0 to 255 for the brightness.</p> <p></p> <p></p> <p>https://docs.micropython.org/en/latest/pyboard/tutorial/fading_led.html</p>"},{"location":"lessons/06-linear-dimmer/#gamma-correction-table","title":"Gamma Correction Table","text":"<pre><code>gamma8= [\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,\n    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,\n   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,\n   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,\n   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,\n   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,\n   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,\n   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,\n   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,\n  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,\n  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,\n  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,\n  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255]\n</code></pre> <pre><code>## Gamma Correction Function\n# input is an integer from 0 to 255\ndef gamma8(input):\n    return gamma8[input]\n</code></pre>"},{"location":"lessons/07-motion/","title":"Motion","text":"<p>Turning individual pixels on and off is pretty easy.  But the results can be pretty boring after a while.  But don't worry, we can now create a program that is a lot more fun!</p> <p>This program uses the Python <code>for</code> loop.  It uses a counter, called an index, to turn on successive pixels in the strip.  For each pixel it turn it on, delays for a short period of time, and then turns it off.  It then moves on to the next pixel until each pixel is the strip has been turned on for short period.</p>"},{"location":"lessons/07-motion/#move-a-red-pixel","title":"Move a Red Pixel","text":"<p>The following program illustrates this process.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# Create a variable to store the delay \ndelay = .03\nwhile True:\n    for i in range(0, NUMBER_PIXELS - 1):\n        # turn index red pixel on for a short delay\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n\n        # turn off\n        strip[i] = (0,0,0)\n</code></pre> <p>You will note that this program is similar to the blink lab with a few key differences:</p> <ol> <li>The code that turns the pixel on and off is inside the for loop.</li> <li>There is no delay or write after we turn it off.  You could add these back in, but they are not really needed.</li> </ol> <p>Note that the delary time in this program is stored in the <code>delay</code> variable and it is a pretty short delay.  The shorter the delay, the faster the pixel will appear to move.</p>"},{"location":"lessons/07-motion/#experiments","title":"Experiments","text":""},{"location":"lessons/07-motion/#change-the-delay","title":"Change the Delay","text":"<p>Try to change the <code>delay</code> variable to different values.  Note how slow the pixel moves if you make the delay a full second.  This is pretty boring.</p> <ol> <li>Change the delay to be .01.  This is 1/100th of a second.</li> <li>What is the fastest you can make the pixel move?</li> <li>What happens if you make the delay less than <code>.001</code>.  Can you still notice the change in the speed?  Many people can't tell the difference because the time to do the <code>strip.write()</code> function is much longer than the delay.</li> </ol>"},{"location":"lessons/07-motion/#down-and-back","title":"Down and Back","text":"<p>Next, lets try to make the pixel appear to move down the LED strip and then back up.  We call this the \"Down and Back\" pattern.  To do this we just need to duplicate the for loop, but change the range of the index.  Instead of going from 0 to NUMBER_PIXELS - 1, we will start at NUMBER_PIXELS - 1 and then go backwards each step:</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n# Create a varuabke to store the delay \ndelay = .01\nwhile True:\n    # move down\n    for i in range(0, NUMBER_PIXELS - 1):\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n        strip[i] = (0,0,0)\n\n    # move back\n    for i in range(NUMBER_PIXELS - 1, 0, -1):\n        # turn index red pixel on for and delay\n        strip[i] = (255,0,0)\n        strip.write()\n        sleep(delay)\n        strip[i] = (0,0,0)\n</code></pre>"},{"location":"lessons/07-motion/#advanced-lab-timeing-the-write","title":"Advanced Lab: Timeing the Write","text":"<p>You can measure the time it takes do perform the <code>strip.write()</code> by recording the number of \"ticks\" before and after the write.  See the function <code>time.ticks_us()</code> for details.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, ticks_us\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nstart = ticks_us()\nstrip.write()\nprint(ticks_us() - start)\n</code></pre> <p>On a 60=pixel strip using the 125MHz Pico I get a value of about 1,960 microseconds or about 2 milliseconds.  The shorter the LED strip, the shorter the delay.  Longer LED strips will have a correspondingly longer delay.</p>"},{"location":"lessons/07-motion/#have-some-fun","title":"Have Some Fun!","text":"<ol> <li>Try to change the color of the pixel.</li> <li>Try to change the direction of motion from the last to the beginning pixel.</li> <li>Try making the </li> </ol>"},{"location":"lessons/07-random/","title":"Using Random Numbers","text":"<p>One fun way to spice up our LED strips is to randomly light up a different pixel with a random color.  Here is how we do this.</p> <p>First, We need to import the library that generate random numbers:</p> <pre><code>from urandom import randint\n</code></pre> <p>Next, we need to generate a random number within a fixed range:</p> <pre><code>    random_red_brightness = randint(0, 256)\n</code></pre> <p>Let's create a program that will briefly light up an random pixel with a random color.  To do this we first generate a random location on the LED strip, then we get a random value for the red, green and blue brightness:</p> <pre><code>location = randint(0, NUMBER_PIXELS-1)\n    red = randint(0, 256)\n    green = randint(0, 256)\n    blue = randint(0, 256)\n</code></pre> <p>Here is the full program.</p> <pre><code># 07-random color at a random location\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\n\nstrip = NeoPixel(Pin(config.NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    location = randint(0, NUMBER_PIXELS-1)\n    red = randint(0, 256)\n    green = randint(0, 256)\n    blue = randint(0, 256)\n    strip[location] = (red, green, blue)\n    strip.write()\n    sleep(.5)\n    strip[location] = (0, 0, 0)\n</code></pre>"},{"location":"lessons/08-color-wipe/","title":"Color Wipe","text":"<p>This lesson shows you how to change the color of the entire LED strip pixel by pixel.  There will be two delays that we can control:</p> <ol> <li>the delay between each pixel update - this is usually about 1/20th of a second</li> <li>the delay between colors - this is usually about 1 to 2 seconds</li> </ol>"},{"location":"lessons/08-color-wipe/#a-simple-color-wipe-function","title":"A Simple Color Wipe Function","text":"<p>To write this program, we will create a simple Python function that will cycle through all the colors in a list.  Our color list will look like this:</p> <pre><code>red = (255, 0, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\n...etc...\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet, white)\n</code></pre> <p>Now with this list</p> <pre><code>def color_wipe(delay, color_delay):\n    for color in colors:\n        for i in range(0, NUMBER_PIXELS):\n            strip[i] = color\n            strip.write()\n            # the delay between each pixel draw\n            sleep(delay)\n        # how long to pause between color changes\n        sleep(color_delay)\n</code></pre> <pre><code>from time import sleep\n\n# most people have a heart rate of around 60-70 beats per minute\n# If you add a once second deplay between \"beats\" you can make and LED\n# look like a beating heart.\n\nNUMBER_PIXELS = 60\nLED_PIN = 0\n\nstrip = NeoPixel(machine.Pin(LED_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet, white)\n\ndef color_wipe(delay, color_delay):\n    for color in colors:\n        for i in range(0, NUMBER_PIXELS):\n            strip[i] = color\n            strip.write()\n            sleep(delay)\n        # how long to pause between color changes\n        sleep(color_delay)\n\nwhile True:\n    color_wipe(.05, 1)\n</code></pre>"},{"location":"lessons/08-moving-bands/","title":"Moving Bands of Color","text":"<p>In this lesson, we will create a program that will move a set of bands of color down the LED strip.  To do this we will create a function called <code>draw_band(start, end, color)</code> that will fill a range of pixels with a given color.</p> <pre><code>def draw_band(start, end, color, delay):\n    # draw the band from start to end\n    for i in range(start, end):\n        strip[i % NUMBER_PIXELS] = color\n</code></pre> <p>This works, but we also have the problem that the last pixel does not get erased</p> <pre><code>def draw_band(start, end, color, erase_tail, delay):\n    # draw the band from start to end\n    for i in range(start, end):\n        strip[i % NUMBER_PIXELS] = color\n    # erase the last pixel on the erase tail band\n    if erase_tail and start &gt; 0:\n        strip[(start-1) % NUMBER_PIXELS] = (0,0,0)\n    strip.write()\n    sleep(delay)\n</code></pre> <p>We can then draw three \"bands\" of color like this:</p> <pre><code>draw_band(0, 9, 'red')\ndraw_band(10, 19, 'green')\ndraw_band(20, 29, 'blue')\n</code></pre> <p>We can make this group of bands appear to move by adding a offset to the start like this:</p> <pre><code>for i in range(0, NUMBER_PIXELS)\n    draw_band(i, i+9, 'red')\n    draw_band(i+10, i+19, 'green')\n    draw_band(i+20, i+29, 'blue')\n</code></pre> <p>This will work fine until the value of i plus the offset exceeds the length of the LED strip.  To get around this, we should never write to location i by itself.  We should always divide i by the strip lenght and write to the remainder, what is call the modulo.  We just have to change one line in the draw_band function:</p> <pre><code>def draw_band(start, end, color):\n    for i in range(start, end):\n        strip[i%NUMBER_PIXELS] = color\n    strip.write()\n</code></pre>"},{"location":"lessons/08-rainbow/","title":"Rainbow","text":"<pre><code>wheel(current_color)\n</code></pre>"},{"location":"lessons/08-rainbow/#09-rainbowpy","title":"09-rainbow.py","text":"<p>from machine import Pin from neopixel import NeoPixel from utime import sleep from urandom import randint</p>"},{"location":"lessons/08-rainbow/#get-the-configuration-information","title":"get the configuration information","text":"<p>import config</p> <p>np = config.NUMBER_PIXELS strip = NeoPixel(Pin(config.NEOPIXEL_PIN), np)</p>"},{"location":"lessons/08-rainbow/#we-have-each-pixel-step-through-the-color-wheel","title":"we have each pixel step through the color wheel","text":"<p>color_wheel_step = int(256 / np)</p> <p>def wheel(pos):     # Input a value 0 to 255 to get a color value.     # The colors are a transition r - g - b - back to r.     if pos &lt; 0 or pos &gt; 255:         return (0, 0, 0)     if pos &lt; 85:         return (255 - pos * 3, pos * 3, 0)     if pos &lt; 170:         pos -= 85         return (0, 255 - pos * 3, pos * 3)     pos -= 170     return (pos * 3, 0, 255 - pos * 3)</p> <p>current_color = 0 print('Drawing rainbow in', np, 'steps with step size of: ', color_wheel_step) for i in range(0,np):     strip[i] = wheel(current_color)     current_color = current_color + color_wheel_step     print(i, current_color, wheel(current_color))     strip.write()     sleep(.03)</p>"},{"location":"lessons/09-comet-tail/","title":"Comet Tail","text":"<p>In this lesson we will make a pattern of light like a comet tail.  The comet will consist of about 5 to 10 pixels in a row and move across the strip by shifting the offset by a single pixel and then redrawing the comet.</p>"},{"location":"lessons/09-comet-tail/#the-draw-comet-tail-function","title":"The Draw Comet Tail Function","text":"<p>Our first task is to draw a single comet tail that will make the head of the comet bright (225) and slowly decrease the brightness behind the head of the comet.  In general, each pixel will be half as bright and the prior pixel.</p> <p>The \"levels\" of brightness can be stored in a list or calculated.  Our list will look like this:</p> <pre><code># brightness levels starting with max and going to 1\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\n</code></pre> <p>Our function will have three parameters:</p> <ol> <li>The offset from pixel 0</li> <li>The color to draw the pixel as a tuple of three integers</li> <li>The delay between the draws which will control the speed that the comet appears to move down the strip</li> </ol> <p>Here is an example of this function:</p> <pre><code># offset should be incremented by one for motion\ndef draw_comet_tail(offset, color, delay):\n    % make sure we are within the range of the LED strip\n    offset = offset % NUMBER_PIXELS\n    for i in range(0, color_count):\n        target = ((level_count - i - 1) + offset) % NUMBER_PIXELS\n        # number to scale by\n        scale = (levels[i] / 255)\n        # set the target and scale and round to the interger value\n        strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))      \n        if offset &gt; 0:\n            strip[offset-1] = (0,0,0)\n        if offset == NUMBER_PIXELS-1:\n            strip[offset] = (0,0,0)\n        strip.write()\n        sleep(delay)\n</code></pre> <p>The most complex line is this one:</p> <pre><code>strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))\n</code></pre> <p>This line sets the RGB values of the target.  It must take the color values that are passed in as parameters and scale them for the current brightness of the tail of the comet.  After it does the multiplication, it must use the <code>int()</code> function to round the value to the nearest integer.</p>"},{"location":"lessons/09-comet-tail/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, indigo, violet, cyan, white)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\n# offset should be incremented by one for motion\ndef draw_comet_tail(offset, color, delay):\n    offset = offset % NUMBER_PIXELS\n    for i in range(0, color_count):\n        target = ((level_count - i - 1) + offset) % NUMBER_PIXELS\n        # number to scale by\n        scale = (levels[i] / 255)\n        strip[target] = (int(color[0]*scale), int(color[1]*scale), int(color[2]*scale))      \n        if offset &gt; 0:\n            strip[offset-1] = (0,0,0)\n        if offset == NUMBER_PIXELS-1:\n            strip[offset] = (0,0,0)\n        strip.write()\n        sleep(delay)\n\n\ndef clear():\n    for i in range(0, NUMBER_PIXELS):\n        strip[i] = (0,0,0)\n    strip.write()\n\n# setup\ncounter = 0\nclear()\n\n# main loop\nwhile True:\n    for color_index in range(0, color_count):\n        for i in range(0, NUMBER_PIXELS):\n            draw_comet_tail(counter, colors[color_index], .005)\n            counter += 1\n            print(counter)\n</code></pre>"},{"location":"lessons/10-moving-rainbow/","title":"Moving Rainbow","text":"<p>In this lesson we will combine the work we did with the color wheel with the motion lesson to create a new lab that moves a block of different colors over the LED strip.  This lab is a little tricker because we need to pay careful attention to our work at the beginning and end of the LED strip to avoid setting values outside the valid indexes of our strip.</p> <p>We will begin with drawing a static hand-built list of colors on our strip.  We call this doing it \"the hard way\".  After that we will show you have to create more a more flexible version using the color wheel function that we covered in a previous lab.</p>"},{"location":"lessons/10-moving-rainbow/#the-classic-rainbow","title":"The Classic Rainbow","text":"<p>Let's begin by simply creating a named list of colors in a rainbow: red, orange, yellow, green, blue, indigo and violet.  We can lookup the red, green and blue values of these colors on Wikipedia.</p> Color Red, Green, and Blue Red 255,0,0 Orange 255,165,0 Yellow 255,255,0 Green 0,255,0 Blue 0,0,255 Indigo 75,0,130 Violet 238,130,238 <p>We can then put the colors into a Python data structure called a list:</p> <pre><code># Color RGB values as tuples\nred = (255, 0, 0)\norange = (255, 165, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (238, 130, 238)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n</code></pre> <p>We can then draw these colors in each of the first seven pixels like this:</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nindex = 0\nfor color in colors:\n    strip[index] = colors[index]\n    index += 1\nstrip.write()\n</code></pre> <p>Here is the important new line:</p> <pre><code>strip[index] = colors[index]\n</code></pre> <p>It says, for the current index, set the strip value to the three values in the colors list.</p> <p>We can then \"move\" this pattern down the strip until we reach the end by redrawing it over and over and erasing it in between.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nfor i in range(0, NUMBER_PIXELS - num_colors + 1):\n    index = 0\n    # draw the rainbow\n    for color in colors:\n        strip[index + i] = colors[index]\n        index += 1\n    strip.write()\n    sleep(.05)\n    # erase the current pixel\n    strip[i] = (0,0,0)\n</code></pre> <p>There are a few tricky adjustments we had to make:</p> <ol> <li>We added the index counter to the strip index so that we would start drawing at a different point each time.</li> <li>We had to not go to the end of the LED strip.  We had to stop <code>num_colors + 1</code> before the end of the strip.</li> <li>We had to erase the current pixel after we drew the colors.</li> </ol>"},{"location":"lessons/10-moving-rainbow/#repeating-the-moving-rainbow","title":"Repeating the Moving Rainbow","text":"<p>Finally, we can wrap this entire section in a <code>while True</code> loop that will keep running the pattern over and over.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\nwhile True:\n    for i in range(0, NUMBER_PIXELS - num_colors + 1):\n        index = 0\n        # draw the rainbow\n        for color in colors:\n            strip[index + i] = colors[index]\n            index += 1\n        strip.write()\n        sleep(.05)\n        # erase the current pixel\n        strip[i] = (0,0,0)\n        # erase the last draw\n        if i == NUMBER_PIXELS - num_colors:\n            strip[i+1] = (0,0,0)\n            strip[i+2] = (0,0,0)\n            strip[i+3] = (0,0,0)\n            strip[i+4] = (0,0,0)\n            strip[i+5] = (0,0,0)\n            strip[i+6] = (0,0,0)\n            strip.write()\n</code></pre> <p>Note that we had to add a few extra lines of code to make the final draw get removed after the last draw in the outer loop.</p>"},{"location":"lessons/10-moving-rainbow/#improving-on-the-moving-rainbow","title":"Improving on the Moving Rainbow","text":"<p>This program is simple to read, but there are several ways we could improve it.</p> <p>One of the awkward characteristics of the program is that he rainbow pattern just suddenly \"appears\" at the front of the strip and then \"dissapers\" at the end of the strip.  This is OK for a strip in a line, but if you wrap the strip in a circle it looks odd.</p> <p>For a circular loop we would like the pattern to appear one pixel at a time and then appear to slide from the end to the beginning of the strip.  We can achieve this by using the modulo function.  It will take a counter and find the \"remainder\" after we divide it by the number of pixels in the strip.</p> <p>What if we wanted our rainbow to be a different number of pixels?  It would be ideal of we could just write a function that would draw the right pixels at the right place.  Perhaps we could just add a parameter to that function for the number of pixels in our rainbow?</p>"},{"location":"lessons/11-rainbow-cycle/","title":"Rainbow Cycle","text":"<p>In this lesson we will use the wheel function to slowly cycle each pixel in a range through each of the colors of the rainbow.</p>"},{"location":"lessons/11-rainbow-cycle/#the-rainbow-cycle-function","title":"The Rainbow Cycle Function","text":"<p>We create a function called <code>rainbow_cycle()</code> that has three parameters.  The first is a delay, the second is a number that increase the precision of the color changes which impacts the speed, the third is how many pixels to skip over.</p> <pre><code>def rainbow_cycle(wait, speed, skip):\n    global NUMBER_PIXELS, strip\n    # get a color - speed will skip intermediate colors for faster cycles\n    for j in range(0, 255, speed):\n        for i in range(0, NUMBER_PIXELS, skip):\n            rc_index = (i * 256 // NUMBER_PIXELS) + j\n            # print(rc_index)\n            strip[i] = wheel(rc_index &amp; 255)\n        strip.write()\n    sleep(wait)\n</code></pre> <p>Next, we place a <code>while True()</code> loop at end and call the function repeatedly.  </p>"},{"location":"lessons/11-rainbow-cycle/#power-considerations","title":"Power Considerations","text":"<p>This program has the ability to drive every single pixel on the strip.  This has the disadvantage that it will drain batteries too quickly or exceed the power levels of a USB power supply.</p> <p>To get around this you can up the <code>skip</code> parameter to only turn on every 2nd, 3rd or 4th pixel.</p> <p>The entire rainbow cycle loop takes a few seconds to run, so be aware of this limitation if you are adding controls or interrupts.</p>"},{"location":"lessons/11-rainbow-cycle/#full-program","title":"Full Program","text":"<p>Here is the full program you can run.  Make sure to change the NUMBER_PIXELS parameter to match the length of your LED strip.</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ndef rainbow_cycle(wait, speed, skip):\n    global NUMBER_PIXELS, strip\n    # get a color - speed will skip intermediate colors for faster cycles\n    for j in range(0, 255, speed):\n        for i in range(0, NUMBER_PIXELS, skip):\n            rc_index = (i * 256 // NUMBER_PIXELS) + j\n            # print(rc_index)\n            strip[i] = wheel(rc_index &amp; 255)\n        strip.write()\n    sleep(wait)\n\n# s[eed is an integer from 1 to 30\nspeed = 2\n# skip = 1 is every pixel, 2 is every other pixel etc.\n# the hither skip the lower the overall power\nskip = 3\nwhile True:\n    rainbow_cycle(.01, speed, skip)\n</code></pre>"},{"location":"lessons/15-random/","title":"Random Drawing","text":"<p>In this lesson we will introduce the ability to draw random colors at random pixels.  This allows us to create more natural patterns such as the flicking light of a candle.</p>"},{"location":"lessons/15-random/#the-random-functions","title":"The Random Functions","text":"<p>We need a function that will generate a random integer between a range of values. This is called the <code>randint()</code> function and it takes either one or two parameters.  In our case, we can just pass in the minimum and maximum values:</p> <pre><code>randint(0, 256)\n</code></pre> <p>You can read more about MicroPython random functions here</p> <p>To use the random function we first need to import the function from the library:</p> <pre><code>from urandom import randint\n</code></pre> <p>Here is a sample loop that sets each pixel to a random color using the wheel() function:</p> <pre><code>for i in range(0, NUMBER_PIXELS):\n    random_color = randint(0, 256)\n    strip[i] = wheel(random_color)\n    strip.write()\n    sleep(.1)\n</code></pre>"},{"location":"lessons/15-random/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ndef clear():\n    for i in range(0, NUMBER_PIXELS):\n        strip[i] = (0,0,0)\n    strip.write()\n\n# setup\ncounter = 0\nclear()\n\n# main loop\nwhile True:\n    for i in range(0, NUMBER_PIXELS):\n        random_color = randint(0, 256)\n        strip[i] = wheel(random_color)\n        strip.write()\n        sleep(.1)\n</code></pre>"},{"location":"lessons/15-random/#exercises","title":"Exercises","text":"<ol> <li>Instead of updating a single pixel in consecutive sequences, can you also use the <code>randint()</code> function to update a random pixel?</li> <li>What if you have a small fixed list of colors to pick from.  How can you use <code>randint()</code> to pick a color from this list?</li> </ol>"},{"location":"lessons/16-candle/","title":"Candle Flicker","text":"<p>In this lesson we will try to simulate the behavior of a flickering candle using the <code>randint()</code> function.  To do this we will need a function that generates a mostly yellow-orange color, but the actual color and and brightness will vary.  This will give the impression of a candle flame with a flicker.</p> <p>A pure yellow color has both the red and green values on and the blue value off:</p> <pre><code>yellow = (255, 255, 0)\norange = (255, 150, 0)\n</code></pre> <p>Our goal is to generate variations in both color and brightness.  We can do this by starteding out with a green that varies from 50 to 200 and a red that varies above this value by 25 to 50.</p>"},{"location":"lessons/16-candle/#sample-candle-function","title":"Sample Candle Function","text":"<p>Our function will draw the new value on a random location on the LED strip.  It will take a single parameter of the delay on how often the values are updated, typically about 1/100th of a second.</p> <pre><code>def candle(delay):\n    for i in range(0, NUMBER_PIXELS):\n         green = 50 + randint(0,155)\n         red = green + randint(25,50)\n         strip[randint(0,NUMBER_PIXELS - 1)] = (red, green, 0)\n         strip.write()\n         sleep(delay)\n</code></pre>"},{"location":"lessons/16-candle/#full-demonstration-program","title":"Full Demonstration Program","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\nfrom urandom import randint\n# https://docs.micropython.org/en/latest/library/random.html\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef candle(delay):\n    for i in range(0, NUMBER_PIXELS):\n         green = 50 + randint(0,155)\n         red = green + randint(25,50)\n         strip[randint(0,NUMBER_PIXELS - 1)] = (red, green, 0)\n         strip.write()\n         sleep(delay)\n\ncounter = 0\nwhile True:\n   candle(.01)\n   # wrap\n   counter = counter % (NUMBER_PIXELS-1)\n   counter += 1\n</code></pre>"},{"location":"lessons/17-theater-chase/","title":"Theater Chase","text":"<p>Theater Chase is a classic pattern that was popularized in marquee signs above movie theaters.  It consists of a row of lights that were usually switched on and off so it would appear that the lights were moving or being chased around the edge of the signs.</p>"},{"location":"lessons/17-theater-chase/#sample-theater-chase-function","title":"Sample Theater Chase Function","text":"<p>To create the illusion of pixels moving along a strip, we need to have three nested loops:</p> <ol> <li>The inner \"i\" loop just moves from 0 to the number of pixels in steps of 3 (or a similarly small number).  It turns every 3rd pixel on, waits and then turns it off</li> <li>The middle \"q\" loop just offsets the starting point of the inner loop moving from values of 0, 1 and 2.  The index in the inner loop is <code>i+q</code>.</li> <li>The outer-most \"j\" loop just indicates how many times the pattern should be repeated</li> </ol> <p>Here is a sample of the <code>theater_chase</code> function that has four parameters:</p> <ol> <li>the LED strip</li> <li>the color</li> <li>the delay (about 50 milliseconds)</li> <li>the number of times the pattern should be repeated (iterations)</li> </ol> <pre><code>def theater_chase(strip, color, wait_ms=50, iterations=10):\n    for j in range(iterations):\n        for q in range(3):\n            # turn every third pixel on\n            for i in range(0, strip.numPixels(), 3):\n                strip[i+q] = color\n            strip.write()\n            # keep the pixels on for a bit like 1/20th of a second\n            sleep_ms(wait_ms)\n            # turn every third pixel off\n            for i in range(0, strip.numPixels(), 3):\n                strip.setPixelColor(i+q, 0)\n</code></pre> <p>If you want to lower the power of the LED strip, you can change the skip number in the inner loop from 3 to 4, 5 or 6 etc.</p>"},{"location":"lessons/17-theater-chase/#full-program","title":"Full Program","text":"<p>This program will run a theater chase for the seven colors of the rainbow and then repeat.</p> <pre><code>from neopixel import NeoPixel\nfrom utime import sleep, sleep_ms\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n# Color RGB values\nred = (255, 0, 0)\norange = (255, 60, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet)\n\ndef theater_chase(strip, color, wait_ms=50, iterations=10):\n    for j in range(iterations):\n        for q in range(3):\n            for i in range(0, strip.numPixels(), 3):\n                strip[i+q] = color\n            strip.write()\n            sleep_ms(wait_ms)\n            for i in range(0, strip.numPixels(), 3):\n                strip.setPixelColor(i+q, 0)\n\nwhile True:\n    # iterate through all the colors\n    for c in range(0, num_colors):\n        theater_chase(strip, colors[c], wait_ms=50, iterations=50)\n</code></pre>"},{"location":"lessons/17-theater-chase/#exercises","title":"Exercises","text":"<ol> <li>Add the skip number as an additional parameter to the function</li> <li>Add another parameter that reversed the direction of the movement</li> <li>Create a function that randomly changes the direction every few seconds</li> </ol>"},{"location":"lessons/18-ripple/","title":"Ripple Patterns","text":"<pre><code># moving rainbow\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef ripple(size, color, delay):\n    # start at a random location within size of the ends\n    start = randint(size, NUMBER_PIXELS - size)\n    for i in range(0, size):\n        strip[start+i] = color\n        strip[start-i] = color\n        strip.write()\n        sleep(delay)\n        strip[start+i] = (0,0,0)\n        strip[start-i] = (0,0,0)\n\ndelay = 0.2\nwhile True:\n    ripple(10, red, delay)\n    ripple(10, green, delay)\n    ripple(10, blue, delay)\n</code></pre>"},{"location":"lessons/18-ripple/#exercises","title":"Exercises","text":"<ol> <li>Make the color random</li> <li>Make the size of the ripple random</li> <li>Add randomness to the delay</li> <li>Use the wheel function to pick a random color</li> <li>Make the pixel intensity get lower as the ripple expands</li> </ol>"},{"location":"lessons/18-twinkle/","title":"Twinkle","text":"<p>A twinkle is a light whose brightness varies repeatedly between bright and faint.</p>"},{"location":"lessons/18-twinkle/#sample-twinkle-function","title":"Sample Twinkle Function","text":"<p>This </p> <pre><code>def twinkle(delay):\n    random_index = randint(0, NUMBER_PIXELS);\n    # turn on\n    strip[random_index] = (255,255,255) \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n</code></pre>"},{"location":"lessons/18-twinkle/#full-program","title":"Full Program","text":"<pre><code>from neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef twinkle(delay):\n    random_index = randint(0, NUMBER_PIXELS-1);\n    # turn on\n    strip[random_index] = (255,255,255) \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n\nwhile True:\n    twinkle(.1)\n    sleep(1)\n</code></pre>"},{"location":"lessons/18-twinkle/#exercises","title":"Exercises","text":"<ol> <li>Add a parameter to the <code>twinkle()</code> function to allow the caller to specify the color.</li> <li>Make the brightness of the twinkle function a random value</li> <li>Make the brightness of a twinkle ramp up and down</li> </ol>"},{"location":"lessons/18-twinkle/#twinkle-random-color","title":"Twinkle Random Color","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, ticks_ms\nfrom urandom import randint\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0, 0, 0)\norange = (140, 60, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\ncyan = (0, 255, 255)\nindigo = (75, 0, 130)\nviolet = (138, 43, 226)\nwhite = (128, 128, 128)\ncolors = (red, orange, yellow, green, blue, cyan, indigo, violet)\ncolor_count = len(colors)\nlevels = [255, 128, 64, 32, 16, 8, 4, 2, 1]\nlevel_count = len(levels)\n\ndef twinkle(delay, color):\n    random_index = randint(0, NUMBER_PIXELS-1);\n    # turn on\n    strip[random_index] = color \n    strip.write();\n    sleep(delay);\n    # turn off\n    strip[random_index] = (0,0,0) \n    strip.write();\n\nwhile True:\n    twinkle(.1, colors[randint(0, color_count-1)])\n    sleep(1)\n</code></pre>"},{"location":"lessons/19-larson-scanner/","title":"Larson Scanner","text":"<p>The Larson Scanner is a light pattern special effect named after Glen A. Larson.  Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience.  See Knight Rider for the backstory.</p>"},{"location":"lessons/19-larson-scanner/#description","title":"Description","text":"<p>A set of usually red pixels moves back and forth over the LED strip.  The pixels are brighter in the center and are dimmer at the edges of the set.  You can see an example of this in the Larson Scanner Pumpkin Kit</p>"},{"location":"lessons/19-larson-scanner/#color-rgb-values","title":"Color RGB values","text":"<p>We will need a set of predefined colors for various brightness of red:</p> <pre><code>red = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0,0,0)\n</code></pre> <p>Note that the color levels are not linear.  You can adjust these and add more intermediate levels for wider patterns.</p>"},{"location":"lessons/19-larson-scanner/#full-source-code","title":"Full Source Code","text":"<pre><code># Larson Scanner - five pixels\nfrom machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 60\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nred = (255, 0, 0)\nred_med = (32, 0, 0)\nred_light = (8, 0, 0)\noff = (0,0,0)\n\ndelay = .05\nwhile True:\n    # forward loop\n    for i in range(2, NUMBER_PIXELS-2):\n        strip[i-2] = red_light\n        strip[i-1] = red_med\n        strip[i] = red\n        strip[i+1] = red_med\n        strip[i+2] = red_light\n        # erase the trailing pixel\n        if i &gt; 0:\n            strip[i-3] = off\n        strip.write()\n        sleep(delay)\n    # backward loop\n    for i in range(NUMBER_PIXELS-4, 1, -1):\n        # erase the trailing pixel\n        if i &lt; NUMBER_PIXELS-2:\n            strip[i+3] = off\n        strip[i-2] = red_light\n        strip[i-1] = red_med\n        strip[i] = red\n        strip[i+1] = red_med\n        strip[i+2] = red_light\n        strip.write()\n        sleep(delay)\n</code></pre>"},{"location":"lessons/19-larson-scanner/#exercises","title":"Exercises","text":"<ol> <li>Turn the code into a function with delay as a patter</li> <li>Add a color parameter</li> <li>Add a parameter for the width of the pattern</li> </ol>"},{"location":"lessons/20-clock/","title":"Clock","text":"<p>Can you turn your LED strip into a clock?</p> <p>You can use binary encoding to display the numbers in a clock.  To do this we will need a function to display a digit as a binary pattern.</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, localtime\n# get the configuration information\nimport config\n\nnp = config.NUMBER_PIXELS\nstrip = NeoPixel(Pin(config.NEOPIXEL_PIN), np)\n\nsec_bits = [0,0,0,0,0,0]\nmin_bits = [0,0,0,0,0,0]\nhr_bits = [0,0,0,0,0,0]\n\ndef decimal_to_binary(n, a):\n    global sec_bits\n    for i in range(0,6):\n        if n % 2:\n            a[i] = 1\n        else:\n            a[i] = 0\n        ## n halfed\n        n //= 2\n\ndef display_binary(binary, index, color):\n    for i in range(0, 6):\n        # print(i, ' ', end='')\n        if binary[i] == 1:\n            strip[index+i] = color\n        else:\n            strip[index+i] = (0,0,0)\n    strip.write()\n\n# light mark and write\ndef display_mark(loc):\n    strip[loc] = (5,5,5)\n    strip.write()\n\n# update from the first time\n# sec\ndisplay_mark(0)\ndisplay_mark(7)\n\n# min\ndisplay_mark(9)\ndisplay_mark(16)\n\n# min\ndisplay_mark(19)\ndisplay_mark(26)\n\nnow = localtime()\nhour = now[3]\n# use AM/PM 12 hour time\nif hour &gt; 12:\n    hour = hour - 12\nminute = now[4]\n\n# this is not working\ndecimal_to_binary(minute, min_bits)\nprint('initial min:', minute, min_bits)\ndisplay_binary(min_bits, 10, (0,10,0))\n\ndecimal_to_binary(hour, hr_bits)\nprint('initial hour:', hour, hr_bits)\ndisplay_binary(hr_bits, 20, (0,0,10))\n\nwhile True:\n    now = localtime()\n    hour = now[3]\n    # use AM/PM 12 hour time\n    if hour &gt; 12:\n        hour = hour - 12\n    minute = now[4]\n    sec = now[5]\n    print(hour, ':', minute, ' ', sec, sep='')\n    strip.write()\n    decimal_to_binary(sec, sec_bits)\n    print('sec:', sec, sec_bits)\n    display_binary(sec_bits, 1, (10,0,0))\n    if sec == 60:\n        minute = minute + 1\n        sec = 0\n        decimal_to_binary(minute, min_bits)\n        print('min:', minute, min_bits)\n        display_binary(min_bits, 10, (0,10,0))\n        if minute == 60:\n            decimal_to_binary(hour, hr_bits)\n            print('hour:', hour, hr_bits)\n            display_binary(hr_bits, 20, (0,0,10))\n            hour = hour + 1\n            minute = 0\n            if hour == 24:\n                hour = 0\n    sleep(1)\n</code></pre>"}]}